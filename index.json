[
{
	"uri": "http://mymneo.github.io/posts/",
	"title": "Posts",
	"tags": [],
	"description": "",
	"content": "Posts AlgorithmApplication grid designkube-proxy topology designcgroup controlle memovim cheatsheetaudit command cheatsheetssh tunnel configurationsocat tipsLinux Administrator commandMySQL cheatsheetport forwarding in windowsrsyslog configurationsymbol legendtcpdump tutorialSVN and Git migrationjq tutorialbehaviors of ext4 file system when devicemapper pool is fullkvm virtual machine with vnc supportfind cheatsheetlvm thin pool cheatsheetresize diskShell Cheatsheetmac cheatsheetgolang memogit commandmakefile memorpmbuild easy tutorialrpm and yum cheatsheetFrequent commands about linux seddocker registryiptables command(docker related)log4j configurationvim plugins"
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/",
	"title": "Algorithm",
	"tags": [],
	"description": "",
	"content": "Posts Reverse Words in a String IIINext Greater Element IMax Consecutive OnesFizz BuzzIsland PerimeterFind All Numbers Disappeared in an ArrayKeyboard RowNumber ComplementHamming DistanceReverse BitsRead N Characters Given Read4Valid ParenthesesRemove Nth Node From End of ListIsomorphic StringsBulls and CowsRectangle AreaContains Duplicate IIMerge Sorted ArrayIntersection of Two Linked ListsImplement Stack using QueuesValid SudokuMinimum Depth of Binary TreePaint FencePath SumGroup Shifted StringsPalindrome NumberPascal's Triangle IIBinary Tree Level Order TraversalFactorial Trailing ZeroesPascal's TriangleRemove Duplicates from Sorted ArrayPower of FourPlus OneRemove ElementBinary Tree Level Order Traversal IIImplement Queue using StacksSymmetric TreeBalanced Binary TreeHouse RobberClosest Binary Search Tree ValueReverse Vowels of a StringSwap Nodes in PairsMerge Two Sorted ListsBest Time to Buy and Sell StockStrobogrammatic NumberUgly NumberHappy NumberPower of TwoPower of ThreeClimbing StairsRemove Duplicates from Sorted ListLinked List CycleNumber of 1 BitsLowest Common Ancestor of a Binary Search TreeRoman to IntegerReverse Linked ListMaximum Size Subarray Sum Equals kMajority ElementContains DuplicateMeeting RoomsExcel Sheet Column NumberValid AnagramSame TreeDelete Node in a Linked ListMove ZeroesFind the CelebrityInvert Binary TreeShortest Word DistanceMaximum Depth of Binary TreeAdd DigitsFlip GamePalindrome PermutationNim GameNested List Weight SumReverse String"
},
{
	"uri": "http://mymneo.github.io/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Just memos "
},
{
	"uri": "http://mymneo.github.io/posts/application-grid-design/",
	"title": "Application grid design",
	"tags": ["linux", "kubernetes", "crd"],
	"description": "",
	"content": "Architecture Summary Application grid is a feature to support such a scenario described as following:\n Application is deployed in many grids, each grid has a number of nodes The pods in each grid can communiate with the others in the same grid by service, other pods which aren\u0026rsquo;t in the same grid can\u0026rsquo;t be in touch with this grid by service. This can be called service isolation. Application keeps some replicas in each grid.  So we create 2 CRD (DeploymentGrid, ServiceGrid) for implements our purpose.\n ServiceGrid  ServiceGrid plays as a template of Service Topology, the controller monitors the changes to this objects, then apply them to Service spec.\nDeploymentGrid  DeploymentsGrid is a higher-level of concept than Deployments. the controller will determine how many Deployments in the cluster and the number of replicas in eacho Deployments. If the specific label of Node changed, controller will re-calculate the replicas of each Deployments under its control even delete them.\nProposal  ServiceGrid  apiVersion: v1alpha1 kind: ServiceGrid metadata: name: servicegrid-demo namespace: default spec: gridUniqKey: zone data: selector: appGrid: nginx ports: - protocol: TCP port: 80 targetPort: 9376 SerivceGrid is a higher-level concept of Service with topology support(1.17) or kube-proxy-wrapper installed.\nDeploymentGrid  apiVersion: v1alpha1 kind: DeploymentGrid metadata: name: deploymentgrid-demo namespace: default spec: gridUniqKey: zone # data is the copy of Deployment without replicas set data: metadata: matchLabels: appGrid: nginx selector: matchLabels: appGrid: nginx template: metadata: labels: appGrid: nginx spec: containers: - name: nginx image: nginx:1.7.9 ports: - containerPort: 80 status: - name: grid-1 availableReplicas: 3 conditions: - lastTransitionTime: \u0026#34;2020-03-02T07:30:01Z\u0026#34; lastUpdateTime: \u0026#34;2020-03-02T07:30:01Z\u0026#34; message: Deployment has minimum availability. reason: MinimumReplicasAvailable status: \u0026#34;True\u0026#34; type: Available - lastTransitionTime: \u0026#34;2020-03-02T07:29:02Z\u0026#34; lastUpdateTime: \u0026#34;2020-03-02T07:30:01Z\u0026#34; message: ReplicaSet \u0026#34;nginx-deployment-54f57cf6bf\u0026#34; has successfully progressed. reason: NewReplicaSetAvailable status: \u0026#34;True\u0026#34; type: Progressing observedGeneration: 1 readyReplicas: 3 replicas: 3 updatedReplicas: 3 "
},
{
	"uri": "http://mymneo.github.io/tags/crd/",
	"title": "crd",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/tags/kubernetes/",
	"title": "kubernetes",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/tags/linux/",
	"title": "linux",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/tags/hijack/",
	"title": "hijack",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/posts/kube-proxy-topology-design/",
	"title": "kube-proxy topology design",
	"tags": ["linux", "kubernetes", "hijack"],
	"description": "",
	"content": "Architecture Summary To support topology in old version kubernetes, we need to add a middleware programm between kube-proxy and kube-apiserver. By this method, we can hijack and modify the data which is sent to kube-proxy. Then we can controll the network rules without change kube-proxy code. We call our programm kube-proxy-wrapper.\nImplementation To keep consistence as much as possible with the latest version of Kubernetes. We also use kubernetes.io/hostname, topology.kubernetes.io/zone and topology.kubernetes.io/region as well-known keys.\nWe choose a annotation topologyKeys for Service to indicate topology concerned key, then label nodes with this key and some value to tell kube-proxy-wrapper the enpoints this node concerns\napiVersion: v1 kind: Service metadata: annotations: topologyKeys: '[\u0026quot;topology.kubernetes.io/zone\u0026quot;]' ... apiVersion: v1 kind: Node metadata: labels: topology.kubernetes.io/zone: 1001 ... kube-proxy-wrapper acts as 2 roles. One is reverse proxy called R, the other one is to manipulate data retrieved from kube-apiserver called M.\nFor the direction from kube-proxy to kube-apiserver, M won\u0026rsquo;t modify any data. But the direction from kube-apiserver to kube-proxy, M will be involved by filtering the endpoints. So the remaining work are that how M get endpoints which it concerns and how network rules flush if node labels are changed.\nM uses 1 informer to get all nodes of this cluster. This is essential component that can be used to divide endpoints into this node concerned and not-concerned. Through this way, we filter the endpoints that this node concerns. And now we focus on how rule flush if our node labels are changed. According to kube-proxy source code, we could send a watch event to kube-proxy, make it thought that endpoints has been changed. By this way kube-proxy will flush all rules.\n"
},
{
	"uri": "http://mymneo.github.io/tags/cgroup/",
	"title": "cgroup",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/posts/cgroup/",
	"title": "cgroup controlle memo",
	"tags": ["linux", "cgroup", "grub"],
	"description": "",
	"content": " Disable cgroup v1 in grub  For Ubuntu:\nvim /etc/default/grub\nGRUB_CMDLINE_LINUX=\u0026quot;cgroup_no_v1=all\u0026quot; "
},
{
	"uri": "http://mymneo.github.io/tags/grub/",
	"title": "grub",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/tags/production/",
	"title": "production",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/tags/vim/",
	"title": "vim",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/posts/vim-cheatsheet/",
	"title": "vim cheatsheet",
	"tags": ["vim", "production"],
	"description": "",
	"content": "VIM cheatsheet  delete lines which matches regex expression  :g/\u0026lt;expr\u0026gt;/d "
},
{
	"uri": "http://mymneo.github.io/tags/audit/",
	"title": "audit",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/posts/audit/",
	"title": "audit command cheatsheet",
	"tags": ["linux", "audit"],
	"description": "",
	"content": "Audit Cheatsheet  audit syscall  auditctl -a exit,always -S \u0026lt;syscall\u0026gt;  audit file  auditctl -w /etc/shadow -p wa  extra option     Tag Description     -b backlog Set max number of outstanding audit buffers allowed (Kernel Default=64) If all buffers are full, the failure flag is consulted by the kernel for action.   -e [0..2] Set enabled flag. When 0 is passed, this can be used to temporarily disable auditing. When 1 is passed as an argument, it will enable auditing. To lock the audit configuration so that it can’t be changed, pass a 2 as the argument. Locking the configuration is intended to be the last command in audit.rules for anyone wishing this feature to be active. Any attempt to change the configuration in this mode will be audited and denied. The configuration can only be changed by rebooting the machine.   -f [0..2] Set failure flag 0=silent 1=printk 2=panic. This option lets you determine how you want the kernel to handle critical errors. Example conditions where this flag is consulted includes: transmission errors to userspace audit daemon, backlog limit exceeded, out of kernel memory, and rate limit exceeded. The default value is 1. Secure environments will probably want to set this to 2.   -h Help   -i Ignore errors when reading rules from a file   -l List all rules 1 per line. This can take a key option (-k), too.   -k key Set a filter key on an audit rule. The filter key is an arbitrary string of text that can be up to 31 bytes long. It can uniquely identify the audit records produced by a rule. Typical use is for when you have several rules that together satisfy a security requirement. The key value can be searched on with ausearch so that no matter which rule triggered the event, you can find its results. The key can also be used on delete all (-D) and list rules (-l) to select rules with a specific key. You may have more than one key on a rule if you want to be able to search logged events in multiple ways or if you have an audispd plugin that uses a key to aid its analysis.   -m text Send a user space message into the audit system. This can only be done by the root user.   -p [r|w|x|a] Set permissions filter for a file system watch. r=read, w=write, x=execute, a=attribute change. These permissions are not the standard file permissions, but rather the kind of syscall that would do this kind of thing. The read \u0026amp; write syscalls are omitted from this set since they would overwhelm the logs. But rather for reads or writes, the open flags are looked at to see what permission was requested.   -q mount-point,subtree If you have an existing directory watch and bind or move mount another subtree in the watched subtree, you need to tell the kernel to make the subtree being mounted equivalent to the directory being watched. If the subtree is already mounted at the time the directory watch is issued, the subtree is automatically tagged for watching. Please note the comma separating the two values. Omitting it will cause errors.   -r rate Set limit in messages/sec (0=none). If this rate is non-zero and is exceeded, the failure flag is consulted by the kernel for action. The default value is 0.   -R file Read rules from a file. The rules must be 1 per line and in the order that they are to be executed in. The rule file must be owned by root and not readable by other users or it will be rejected. The rule file may have comments embedded by starting the line with a ’#’ character. Rules that are read from a file are identical to what you would type on a command line except they are not preceeded by auditctl (since auditctl is the one executing the file).   -s Report status. Note that a pid of 0 indicates that the audit daemon is not running.   -t Trim the subtrees after a mount command.   -a list,action Append rule to the end of list with action. Please note the comma separating the two values. Omitting it will cause errors.   -A list,action Add rule to the beginning list with action.   -d list,action Delete rule from list with action. The rule is deleted only if it exactly matches syscall name and field names.   -D Delete all rules and watches. This can take a key option (-k), too.   -S [Syscall name or number|all] Any syscall name or number may be used. The word ’all’ may also be used. If this syscall is made by a program, then start an audit record. If a field rule is given and no syscall is specified, it will default to all syscalls. You may also specify multiple syscalls in the same rule by using multiple -S options in the same rule. Doing so improves performance since fewer rules need to be evaluated. If you are on a bi-arch system, like x86_64, you should be aware that auditctl simply takes the text, looks it up for the native arch (in this case b64) and sends that rule to the kernel. If there are no additional arch directives, IT WILL APPLY TO BOTH 32 \u0026amp; 64 BIT SYSCALLS. This can have undesirable effects since there is no guarantee that, for example, the open syscall has the same number on both 32 and 64 bit interfaces. You may want to control this and write 2 rules, one with arch equal to b32 and one with b64 to make sure the kernel finds the events that you intend.   -F [n=v | n!=v | n\u0026lt;v | n\u0026gt;v | n\u0026lt;=v | n\u0026gt;=v | n\u0026amp;v | n\u0026amp;=v] Build a rule field: name, operation, value. You may have up to 64 fields passed on a single command line. Each one must start with -F. Each field equation is anded with each other to trigger an audit record. There are 8 operators supported - equal, not equal, less than, greater than, less than or equal, and greater than or equal, bit mask, and bit test respectively. Bit test will \u0026ldquo;and\u0026rdquo; the values and check that they are equal, bit mask just \u0026ldquo;ands\u0026rdquo; the values. Fields that take a user ID may instead have the user’s name; the program will convert the name to user ID. The same is true of group names.   -w path Insert a watch for the file system object at path. You cannot insert a watch to the top level directory. This is prohibited by the kernel. Wildcards are not supported either and will generate a warning. The way that watches work is by tracking the inode internally. If you place a watch on a file, its the same as using the -F path option on a syscall rule. If you place a watch on a directory, its the same as using the -F dir option on a syscall rule. The -w form of writing watches is for backwards compatibility and the syscall based form is more expressive. Unlike most syscall auditing rules, watches do not impact performance based on the number of rules sent to the kernel. The only valid options when using a watch are the -p and -k. If you need to anything fancy like audit a specific user accessing a file, then use the syscall auditing form with the path or dir fields. See the EXAMPLES section for an example of converting one form to another.   -W path Remove a watch for the file system object at path.    -a list\n   Tag Description     task Add a rule to the per task list. This rule list is used only at the time a task is created \u0026ndash; when fork() or clone() are called by the parent task. When using this list, you should only use fields that are known at task creation time, such as the uid, gid, etc.   entry Add a rule to the syscall entry list. This list is used upon entry to a system call to determine if an audit event should be created.   exit Add a rule to the syscall exit list. This list is used upon exit from a system call to determine if an audit event should be created.   user Add a rule to the user message filter list. This list is used by the kernel to filter events originating in user space before relaying them to the audit daemon. It should be noted that the only fields that are valid are: uid, auid, gid, and pid. All other fields will be treated as non-matching.   exclude Add a rule to the event type exclusion filter list. This list is used to filter events that you do not want to see. For example, if you do not want to see any avc messages, you would using this list to record that. The message type that you do not wish to see is given with the msgtype field.    -a action\n   Tag Description     never No audit records will be generated. This can be used to suppress event generation. In general, you want suppressions at the top of the list instead of the bottom. This is because the event triggers on the first matching rule.   always Allocate an audit context, always fill it in at syscall entry time, and always write out a record at syscall exit time.    -F field\n   Tag Description     a0, a1, a2, a3 Respectively, the first 4 arguments to a syscall. Note that string arguments are not supported. This is because the kernel is passed a pointer to the string. Triggering on a pointer address value is not likely to work. So, when using this, you should only use on numeric values. This is most likely to be used on platforms that multiplex socket or IPC operations.   arch The CPU architecture of the syscall. The arch can be found doing ’uname -m’. If you do not know the arch of your machine but you want to use the 32 bit syscall table and your machine supports 32 bit, you can also use b32 for the arch. The same applies to the 64 bit syscall table, you can use b64. In this way, you can write rules that are somewhat arch independent because the family type will be auto detected. However, syscalls can be arch specific and what is available on x86_64, may not be available on ppc. The arch directive should preceed the -S option so that auditctl knows which internal table to use to look up the syscall numbers.   auid The original ID the user logged in with. Its an abbreviation of audit uid. Sometimes its referred to as loginuid. Either the text or number may be used.   devmajor Device Major Number   devminor Device Minor Number   dir Full Path of Directory to watch. This will place a recursive watch on the directory and its whole subtree. Should only be used on exit list. See \u0026ldquo;-w\u0026rdquo;.   egid Effective Group ID   euid Effective User ID   exit Exit value from a syscall. If the exit code is an errno, you may use the text representation, too.   fsgid Filesystem Group ID   fsuid Filesystem User ID   filetype The target file’s type. Can be either file, dir, socket, symlink, char, block, or fifo.   gid Group ID   inode Inode Number   key This is another way of setting a filter key. See discussion above for -k option.   msgtype This is used to match the message type number. It should only be used on the exclude filter list.   obj_user Resource’s SE Linux User   obj_role Resource’s SE Linux Role   obj_type Resource’s SE Linux Type   obj_lev_low Resource’s SE Linux Low Level   obj_lev_high Resource’s SE Linux High Level   path Full Path of File to watch. Should only be used on exit list.   perm Permission filter for file operations. See \u0026ldquo;-p\u0026rdquo;. Should only be used on exit list. You can use this without specifying a syscall and the kernel will select the syscalls that satisfy the permissions being requested.   pers OS Personality Number   pid Process ID   ppid Parent’s Process ID   subj_user Program’s SE Linux User   subj_role Program’s SE Linux Role   subj_type Program’s SE Linux Type   subj_sen Program’s SE Linux Sensitivity   subj_clr Program’s SE Linux Clearance   sgid Saved Group ID. See getresgid(2) man page.   success If the exit value is \u0026gt;= 0 this is true/yes otherwise its false/no. When writing a rule, use a 1 for true/yes and a 0 for false/no   suid Saved User ID. See getresuid(2) man page.   uid User ID    "
},
{
	"uri": "http://mymneo.github.io/tags/ssh/",
	"title": "ssh",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/posts/ssh-tunnel/",
	"title": "ssh tunnel configuration",
	"tags": ["linux", "ssh"],
	"description": "",
	"content": "SSH Tunnel Configuration You basically have three possibilities:\n Tunnel from localhost to host1:  ssh -L 9999:host2:1234 -N host1 As noted above, the connection from host1 to host2 will not be secured.\n Tunnel from localhost to host1 and from host1 to host2:  ssh -L 9999:localhost:9999 host1 ssh -L 9999:localhost:1234 -N host2 This will open a tunnel from localhost to host1 and another tunnel from host1 to host2. However the port 9999 to host2:1234 can be used by anyone on host1. This may or may not be a problem.\n Tunnel from localhost to host1 and from localhost to host2:  ssh -L 9998:host2:22 -N host1 ssh -L 9999:localhost:1234 -N -p 9998 localhost This will open a tunnel from localhost to host1 through which the SSH service on host2 can be used. Then a second tunnel is opened from localhost to host2 through the first tunnel.\nNormally, I\u0026rsquo;d go with option 1. If the connection from host1 to host2 needs to be secured, go with option 2. Option 3 is mainly useful to access a service on host2 that is only reachable from host2 itself.\n"
},
{
	"uri": "http://mymneo.github.io/posts/socat-tips/",
	"title": "socat tips",
	"tags": ["linux"],
	"description": "",
	"content": "Tips for socat  listen tcp port and transport data to unix socket  socat TCP-LISTEN:\u0026lt;port\u0026gt;,fork UNIX:\u0026lt;socket file\u0026gt;  listen tcp prot and transport data to abstract unix socket  socat TCP-LISTEN:\u0026lt;port\u0026gt;,fork ABSTRACT:\u0026lt;abstract socket file\u0026gt; "
},
{
	"uri": "http://mymneo.github.io/posts/linux-administrator-command/",
	"title": "Linux Administrator command",
	"tags": ["linux"],
	"description": "",
	"content": "Commands for administrator  Disable expiration of a user   Minimum Password Age to 0 Maximum Password Age to 99999 Password Inactive to -1 Account Expiration Date to -1\n chage -I -1 -m 0 -M 99999 -E -1 \u0026lt;username\u0026gt; "
},
{
	"uri": "http://mymneo.github.io/tags/algorithm/",
	"title": "algorithm",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/tags/leetcode/",
	"title": "leetcode",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/reverse-words-in-a-string-iii/",
	"title": "Reverse Words in a String III",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.\nExample 1: Input: \u0026ldquo;Let\u0026rsquo;s take LeetCode contest\u0026rdquo; Output: \u0026ldquo;s\u0026rsquo;teL ekat edoCteeL tsetnoc\u0026rdquo; Note: In the string, each word is separated by single space and there will not be any extra space in the string.\n Analysis: 找到一个单词的分界,然后翻转,repeat\nTime and space complexity: time: $\\Theta (n)$\nspace: $\\Theta (1)$\nCode: class Solution { public: string reverseWords(string s) { for (int i = 0; i \u0026lt; s.length(); i++) { if (s[i] != \u0026#39; \u0026#39;) { // when i is a non-space  int j = i; for (; j \u0026lt; s.length() \u0026amp;\u0026amp; s[j] != \u0026#39; \u0026#39;; j++) { } // move j to the next space  reverse(s.begin() + i, s.begin() + j); i = j - 1; } } return s; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/next-greater-element-i/",
	"title": "Next Greater Element I",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " First array, there is no next greater number for it in the second array, so output -1. Example 2: Input: nums1 = [2,4], nums2 = [1,2,3,4]. Output: [3,-1] Explanation: For number 2 in the first array, the next greater number for it in the second array is 3. For number 4 in the first array, there is no next greater number for it in the second array, so output -1. Note: All elements in nums1 and nums2 are unique. The length of both nums1 and nums2 would not exceed 1000.\n Analysis: 利用stack记录逆序的序列,当stack的top元素小于当前读取元素的时候,就记录一下top元素的下一个元素就是当前元素,最后记录的结果查询输入的最终结果\nTime and space complexity: time: $\\Theta (n)$\nspace: $\\Theta (n)$\nCode: #ifdef CONFIG_H #include \u0026#34;../config.h\u0026#34;#endif  class Solution { public: vector\u0026lt;int\u0026gt; nextGreaterElement(vector\u0026lt;int\u0026gt;\u0026amp; findNums, vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; ret; stack\u0026lt;int\u0026gt; sub; unordered_map\u0026lt;int, int\u0026gt; lookup; for (auto n : nums) { while (!sub.empty() \u0026amp;\u0026amp; sub.top() \u0026lt; n) { lookup.insert(make_pair(sub.top(), n)); sub.pop(); } sub.push(n); } for (auto n : findNums) { auto test = lookup.find(n); if (test == lookup.end()) { ret.push_back(-1); } else { ret.push_back(test-\u0026gt;second); } } return ret; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/max-consecutive-ones/",
	"title": "Max Consecutive Ones",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given a binary array, find the maximum number of consecutive 1s in this array.\nExample 1: Input: [1,1,0,1,1,1] Output: 3 Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. Note:\nThe input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000\n Analysis: 简单的数组问题\nTime and space complexity: time: $\\Theta (n)$\nspace: $\\Theta (n)$\nCode: #ifdef CONFIG_H #include \u0026#34;../config.h\u0026#34;#endif  class Solution { public: int findMaxConsecutiveOnes(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int max_length = 0; int i, j; for (i = 0; i \u0026lt; nums.size(); ++i) { j = i; if (!nums[j]) { continue; } while (j \u0026lt; nums.size() \u0026amp;\u0026amp; nums[j]) { ++j; } max_length = max(max_length, j - i); i = j; } return max_length; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/fizz-buzz/",
	"title": "Fizz Buzz",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Write a program that outputs the string representation of numbers from 1 to n.\nBut for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.\nExample:\nn = 15,\nReturn: [ \u0026ldquo;1\u0026rdquo;, \u0026ldquo;2\u0026rdquo;, \u0026ldquo;Fizz\u0026rdquo;, \u0026ldquo;4\u0026rdquo;, \u0026ldquo;Buzz\u0026rdquo;, \u0026ldquo;Fizz\u0026rdquo;, \u0026ldquo;7\u0026rdquo;, \u0026ldquo;8\u0026rdquo;, \u0026ldquo;Fizz\u0026rdquo;, \u0026ldquo;Buzz\u0026rdquo;, \u0026ldquo;11\u0026rdquo;, \u0026ldquo;Fizz\u0026rdquo;, \u0026ldquo;13\u0026rdquo;, \u0026ldquo;14\u0026rdquo;, \u0026ldquo;FizzBuzz\u0026rdquo; ]\n Analysis: 基础题\nTime and space complexity: time: $\\Theta (n)$\nspace: $\\Theta (n)$\nCode: #ifdef CONFIG_H #include \u0026#34;../config.h\u0026#34;#endif  class Solution { public: vector\u0026lt;string\u0026gt; fizzBuzz(int n) { vector\u0026lt;string\u0026gt; ret; for (int i = 1; i \u0026lt;= n; ++i) { string item; if (i % 3 == 0 \u0026amp;\u0026amp; i % 5 == 0) { item = \u0026#34;FizzBuzz\u0026#34;; } else if (i % 3 == 0) { item = \u0026#34;Fizz\u0026#34;; } else if (i % 5 == 0) { item = \u0026#34;Buzz\u0026#34;; } else { item = to_string(i); } ret.push_back(item); } return ret; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/island-perimeter/",
	"title": "Island Perimeter",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn\u0026rsquo;t have \u0026ldquo;lakes\u0026rdquo; (water inside that isn\u0026rsquo;t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don\u0026rsquo;t exceed 100. Determine the perimeter of the island.\nExample:\n[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]]\nAnswer: 16 Explanation: The perimeter is the 16 yellow stripes in the image below:  Analysis: 本质上就是计算相连正方形有多少条边, 任意2个正方形相连,会重复计算2次边长, 所以最后的答案就是(正方形总数*4-相连的正方形数量*2)\nTime and space complexity: time: $\\Theta (n)$\nspace: $\\Theta (n)$\nCode: #ifdef CONFIG_H #include \u0026#34;../config.h\u0026#34;#endif  class Solution { public: int islandPerimeter(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int island = 0, neighbour = 0; for (int i = 0; i \u0026lt; grid.size(); ++i) { for (int j = 0; j \u0026lt; grid.front().size(); ++j) { if (grid[i][j]) { ++island; if (i \u0026lt; grid.size() - 1 \u0026amp;\u0026amp; grid[i + 1][j]) { ++neighbour; } if (j \u0026lt; grid.front().size() - 1 \u0026amp;\u0026amp; grid[i][j + 1]) { ++neighbour; } } } } return (island \u0026lt;\u0026lt; 2) - (neighbour \u0026lt;\u0026lt; 1); } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/find-all-numbers-disappeared-in-an-array/",
	"title": "Find All Numbers Disappeared in an Array",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others \u0026gt;appear once.\nFind all the elements of [1, n] inclusive that do not appear in this array.\nCould you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.\nExample:\nInput: [4,3,2,7,8,2,3,1]\nOutput: [5,6]\n Analysis: 一种方式像Union Find一样,每个元素是不是属于当前这个slot,如果不是就和该元素应该属于的位置交换,直到满足条件.\n另外一种方式, 先遍历一遍标记当前元素应该在的位置上的元素为负数,再遍历一遍,如果该位置的元素仍然是大于0的数,那么该元素就是缺失元素\nTime and space complexity: time: $\\Theta (n)$\nspace: $\\Theta (1)$\nCode: #ifdef CONFIG_H #include \u0026#34;../config.h\u0026#34;#endif  class Solution { public: vector\u0026lt;int\u0026gt; findDisappearedNumbers(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for (int i = 0; i \u0026lt; nums.size(); ++i) { int change; while (nums[i] != i + 1) { change = nums[i] - 1; if (nums[change] != change + 1) { swap(nums[change], nums[i]); continue; } break; } } vector\u0026lt;int\u0026gt; ret; for (int i = 0; i \u0026lt; nums.size(); ++i) { if (i + 1 != nums[i]) { ret.push_back(i + 1); } } return ret; } }; #ifdef CONFIG_H #include \u0026#34;../config.h\u0026#34;#endif  class Solution { public: vector\u0026lt;int\u0026gt; findDisappearedNumbers(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int index; for (int i = 0; i \u0026lt; nums.size(); ++i) { index = abs(nums[i]) - 1; if (nums[index] \u0026gt; 0) { nums[index] = -nums[index]; } } vector\u0026lt;int\u0026gt; ret; for (int i = 0; i \u0026lt; nums.size(); ++i) { if (nums[i] \u0026gt; 0) { ret.push_back(i + 1); } } return ret; } }; "
},
{
	"uri": "http://mymneo.github.io/tags/mysql/",
	"title": "mysql",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/posts/mysql-cheatsheet/",
	"title": "MySQL cheatsheet",
	"tags": ["linux", "mysql"],
	"description": "",
	"content": " select   normal select  SELECT column1, column2, ... FROM table_name; Derived Tables  SELECT column1, column2, ... FROM (subquery) [AS] tbl_name ...  encoding  set CHARACTER SET (encoding) "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/keyboard-row/",
	"title": "Keyboard Row",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given a List of words, return the words that can be typed using letters of alphabet on only one row\u0026rsquo;s of American keyboard like the image below.\n Example 1:\nInput: [\u0026quot;Hello\u0026quot;, \u0026quot;Alaska\u0026quot;, \u0026quot;Dad\u0026quot;, \u0026quot;Peace\u0026quot;] Output: [\u0026quot;Alaska\u0026quot;, \u0026quot;Dad\u0026quot;] Note:\n You may use one character in the keyboard more than once. You may assume the input string will only contain letters of alphabet.  Analysis: 对每一行的字母编码,qwertyuiop编码001,asdfghjkl编码010,zxcvbnm编码100,遍历每个字串的每个字母,如果都是同一行的字母,那么所有的编码做与操作都是同一个编码,不然就会是0\nTime and space complexity: time: $\\Theta (n*m) $\nn represents number of strings, m represents length of string\nspace: $\\Theta (1) $\nCode: class Solution { public: Solution() { lookup.resize(26); vector\u0026lt;string\u0026gt; rows = {\u0026#34;QWERTYUIOP\u0026#34;, \u0026#34;ASDFGHJKL\u0026#34;, \u0026#34;ZXCVBNM\u0026#34;}; int index; for (int i = 0; i \u0026lt; rows.size(); ++i) { index = 1 \u0026lt;\u0026lt; i; for (auto c : rows[i]) { lookup[c - \u0026#39;A\u0026#39;] = index; } } } public: vector\u0026lt;string\u0026gt; findWords(vector\u0026lt;string\u0026gt;\u0026amp; words) { vector\u0026lt;string\u0026gt; ret; int id; for (auto str : words) { id = 7; for (auto c : str) { id \u0026amp;= lookup[toupper(c) - \u0026#39;A\u0026#39;]; if (id == 0) { break; } } if (id) { ret.push_back(str); } } return ret; } private: vector\u0026lt;int\u0026gt; lookup; }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/number-complement/",
	"title": "Number Complement",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.\nNote:\nThe given integer is guaranteed to fit within the range of a 32-bit signed integer. You could assume no leading zero bit in the integer’s binary representation.\n Exammple: Input: 5 Output: 2 Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. Input: 1 Output: 0 Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0. Analysis: 找出大于该数的最小2的幂-1,然后与数字做异或操作.\n大于某一个数字的最小2的幂:\nx |= x \u0026gt;\u0026gt; 1; x |= x \u0026gt;\u0026gt; 2; x |= x \u0026gt;\u0026gt; 4; x |= x \u0026gt;\u0026gt; 8; x |= x \u0026gt;\u0026gt; 16; ++x; Time and space complexity: time: $\\Theta (1) $\nspace: $\\Theta (1) $\nCode: class Solution { public: int findComplement(int num) { int mask = num; mask |= mask \u0026gt;\u0026gt; 1; mask |= mask \u0026gt;\u0026gt; 2; mask |= mask \u0026gt;\u0026gt; 4; mask |= mask \u0026gt;\u0026gt; 8; mask |= mask \u0026gt;\u0026gt; 16; return num ^ mask; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/hamming-distance/",
	"title": "Hamming Distance",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\nGiven two integers x and y, calculate the Hamming distance.\n Note: $ 0 \u0026lt;= x, y \u0026lt; 2^{31} $\nAnalysis: divide and conquer, 先1位计算,再2位计算,一直到16位\nTime and space complexity: time: $\\Theta (1) $\nspace: $\\Theta (1) $\nCode: class Solution { public: int hammingDistance(int x, int y) { return pop(x ^ y); } int pop(int x) { x = ((x \u0026gt;\u0026gt; 1) \u0026amp; 0x55555555) + (x \u0026amp; 0x55555555); x = ((x \u0026gt;\u0026gt; 2) \u0026amp; 0x33333333) + (x \u0026amp; 0x33333333); x = ((x \u0026gt;\u0026gt; 4) \u0026amp; 0x0f0f0f0f) + (x \u0026amp; 0x0f0f0f0f); x = ((x \u0026gt;\u0026gt; 8) \u0026amp; 0x00ff00ff) + (x \u0026amp; 0x00ff00ff); x = ((x \u0026gt;\u0026gt; 16) \u0026amp; 0x0000ffff) + (x \u0026amp; 0x0000ffff); return x; } }; "
},
{
	"uri": "http://mymneo.github.io/tags/netsh/",
	"title": "netsh",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/posts/port-forwarding-in-windows/",
	"title": "port forwarding in windows",
	"tags": ["windows", "netsh"],
	"description": "",
	"content": "Port forwarding configuration  Add rule   forward A:B to C:D  netsh interface portproxy add v4tov4 listenaddress=A listenport=B connectaddress=C connectport=D Delete rule   delete A:B  netsh interface portproxy delete v4tov4 listenaddress=A listenport=B List all rules  netsh interface portproxy show all "
},
{
	"uri": "http://mymneo.github.io/tags/windows/",
	"title": "windows",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/tags/log/",
	"title": "log",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/posts/rsyslog-configuration/",
	"title": "rsyslog configuration",
	"tags": ["linux", "log"],
	"description": "",
	"content": " configuration file location  /etc/rsyslog.conf /etc/rsyslog.d/ rotate configuration location  /etc/logrotate.d/rsyslog rotate options  The following is a list of some of the directives you can specify in your logrotate configuration file:\n  weekly — Specifies the rotation of log files to be done weekly. Similar directives include:\n daily monthly yearly    compress — Enables compression of rotated log files. Similar directives include:\n nocompress compresscmd — Specifies the command to be used for compressing. uncompresscmd compressext — Specifies what extension is to be used for compressing. compressoptions — Specifies any options to be passed to the compression program used. delaycompress — Postpones the compression of log files to the next rotation of log files.    rotate INTEGER — Specifies the number of rotations a log file undergoes before it is removed or mailed to a specific address. If the value 0 is specified, old log files are removed instead of rotated.\n  mail ADDRESS — This option enables mailing of log files that have been rotated as many times as is defined by the rotate directive to the specified address. Similar directives include:\n nomail mailfirst — Specifies that the just-rotated log files are to be mailed, instead of the about-to-expire log files. maillast — Specifies that the about-to-expire log files are to be mailed, instead of the just-rotated log files. This is the default option when mail is enabled.    FAQ:    Q: Restart rsyslog since rsyslog configuration is changed, no log output\nA: remove /var/lib/rsyslog/imjournal.state, then restart rsyslog\n  "
},
{
	"uri": "http://mymneo.github.io/tags/english/",
	"title": "english",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/posts/symbol-legend/",
	"title": "symbol legend",
	"tags": ["english"],
	"description": "",
	"content": "+　加号；正号 -　minus　减号；负号 ±　plus or minus　正负号 ×　is multiplied by　乘号 ÷　is divided by　除号 ＝　is equal to　等于号 ≠　is not equal to　不等于号 ≡　is equivalent to　全等于号 ≌　is equal to or approximately equal to　等于或约等于号 ≈　is approximately equal to　约等于号 ＜　is less than　小于号 ＞　is greater than　大于号 ≮　is not less than　不小于号 ≯　is not more than　不大于号 ≤　is less than or equal to　小于或等于号 ≥　is more than or equal to　大于或等于号 %　per cent　百分之…… ‰　per mill 千分之…… ∞　infinity　无限大号 ∝　varies as　与……成比例 √　(square) root　（平方）根 ∵　since; because　因为 ∴　hence　所以 ∷　equals; as (proportion)　等于；成比例 ∠　angle　角 ⌒　semicircle　半圆 ⊙　circle　圆 ○　circumference　圆周 π　pi 圆周率 △　triangle　三角形 ⊥　perpendicular to　垂直于 ∪　union of　并；合集 ∩　intersection of 交；通集 ∫　the integral of ……的积分 ∑　(sigma) summation of　总和 °　degree　度 ′　minute　分 ″　second　秒 ℃　Celsius system　摄氏度 {　open brace; open curly　左花括号 }　close brace; close curly　右花括号 (　open parenthesis; open paren　左圆括号 )　close parenthesis; close paren　右圆括号 () brakets; parentheses　括号 [　open bracket 左方括号 ]　close bracket 右方括号 [] square brackets　方括号 .　period; dot　句号；点 |　vertical bar; vertical virgule　竖线 \u0026amp;　ampersand; and; reference; ref　和；引用 *　asterisk; multiply; star; pointer　星号；乘号；星；指针 /　slash; divide; oblique 斜线；斜杠；除号 //　slash-slash; comment 双斜线；注释符 #　pound　井号 \\　backslash; sometimes escape　反斜线转义符；有时表示转义符或续行符 ~　tilde　波浪符 .　full stop　句号 ,　comma　逗号 :　colon　冒号 ;　semicolon　分号 ?　question mark　问号 !　exclamation mark (英式英语)；exclamation point (美式英语) '　apostrophe　撇号；省字符 -　hyphen　连字号 -- dash 破折号 ...　dots/ellipsis　省略号 \u0026quot;　single quotation marks 单引号 \u0026quot;\u0026quot;　double quotation marks 双引号 ‖ parallel 双线号 \u0026amp;　ampersand = and ～　swung dash 代字号 §　section; division 分节号 →　arrow 箭号；参见号 "
},
{
	"uri": "http://mymneo.github.io/tags/tcpdump/",
	"title": "tcpdump",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/posts/tcpdump/",
	"title": "tcpdump tutorial",
	"tags": ["linux", "tcpdump"],
	"description": "",
	"content": "Tcpdump usage example  See the list of interfaces on which tcpdump can listen:  tcpdump -D  Listen on interface eth0:  tcpdump -i eth0  Listen on any available interface (cannot be done in promiscuous mode. Requires Linux kernel 2.2 or greater):  tcpdump -i any  Be verbose while capturing packets:  tcpdump -v  Be more verbose while capturing packets:  tcpdump -vv  Be very verbose while capturing packets:  tcpdump -vvv  Be verbose and print the data of each packet in both hex and ASCII, excluding the link level header:  tcpdump -v -X  Be verbose and print the data of each packet in both hex and ASCII, also including the link level header:  tcpdump -v -XX  Be less verbose (than the default) while capturing packets:  tcpdump -q  Limit the capture to 100 packets:  tcpdump -c 100  Record the packet capture to a file called capture.cap:  tcpdump -w capture.cap  Record the packet capture to a file called capture.cap but display on-screen how many packets have been captured in real-time:  tcpdump -v -w capture.cap  Display the packets of a file called capture.cap:  tcpdump -r capture.cap  Display the packets using maximum detail of a file called capture.cap:  tcpdump -vvv -r capture.cap  Display IP addresses and port numbers instead of domain and service names when capturing packets (note: on some systems you need to specify -nn to display port numbers):  tcpdump -n  Capture any packets where the destination host is 192.168.1.1. Display IP addresses and port numbers:  tcpdump -n dst host 192.168.1.1  Capture any packets where the source host is 192.168.1.1. Display IP addresses and port numbers:  tcpdump -n src host 192.168.1.1  Capture any packets where the source or destination host is 192.168.1.1. Display IP addresses and port numbers:  tcpdump -n host 192.168.1.1  Capture any packets where the destination network is 192.168.1.0/24. Display IP addresses and port numbers:  tcpdump -n dst net 192.168.1.0/24  Capture any packets where the source network is 192.168.1.0/24. Display IP addresses and port numbers:  tcpdump -n src net 192.168.1.0/24  Capture any packets where the source or destination network is 192.168.1.0/24. Display IP addresses and port numbers:  tcpdump -n net 192.168.1.0/24  Capture any packets where the destination port is 23. Display IP addresses and port numbers:  tcpdump -n dst port 23  Capture any packets where the destination port is is between 1 and 1023 inclusive. Display IP addresses and port numbers:  tcpdump -n dst portrange 1-1023  Capture only TCP packets where the destination port is is between 1 and 1023 inclusive. Display IP addresses and port numbers:  tcpdump -n tcp dst portrange 1-1023  Capture only UDP packets where the destination port is is between 1 and 1023 inclusive. Display IP addresses and port numbers:  tcpdump -n udp dst portrange 1-1023  Capture any packets with destination IP 192.168.1.1 and destination port 23. Display IP addresses and port numbers:  tcpdump -n \u0026quot;dst host 192.168.1.1 and dst port 23\u0026quot;  Capture any packets with destination IP 192.168.1.1 and destination port 80 or 443. Display IP addresses and port numbers:  tcpdump -n \u0026quot;dst host 192.168.1.1 and (dst port 80 or dst port 443)\u0026quot;  Capture any ICMP packets:  tcpdump -v icmp  Capture any ARP packets:  tcpdump -v arp  Capture either ICMP or ARP packets:  tcpdump -v \u0026quot;icmp or arp\u0026quot;  Capture any packets that are broadcast or multicast:  tcpdump -n \u0026quot;broadcast or multicast\u0026quot;  Capture 500 bytes of data for each packet rather than the default of 68 bytes:  tcpdump -s 500  Capture all bytes of data within the packet:  tcpdump -s 0 "
},
{
	"uri": "http://mymneo.github.io/tags/git/",
	"title": "git",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/tags/svn/",
	"title": "svn",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/posts/svn2git/",
	"title": "SVN and Git migration",
	"tags": ["linux", "svn", "git"],
	"description": "",
	"content": "Import svn project into your git project git config --add svn-remote.\u0026lt;branch name\u0026gt;.url \u0026lt;svn repository url\u0026gt; git config --add svn-remote.\u0026lt;branch name\u0026gt;.fetch :refs/remotes/\u0026lt;branch name\u0026gt; git svn fetch \u0026lt;branch name\u0026gt; [-r\u0026lt;rev\u0026gt;] Export and import SVN repository svnrdump dump [-r\u0026lt;rev\u0026gt;] \u0026lt;svn repostory url\u0026gt; \u0026gt; \u0026lt;dump file\u0026gt; svnadmin load --force-uuid \u0026lt;directory\u0026gt; \u0026lt; \u0026lt;dump file\u0026gt; "
},
{
	"uri": "http://mymneo.github.io/tags/jq/",
	"title": "jq",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/posts/jq-tutorial/",
	"title": "jq tutorial",
	"tags": ["jq"],
	"description": "",
	"content": "Example json file\n{ \u0026#34;id\u0026#34;: { \u0026#34;bioguide\u0026#34;: \u0026#34;E000295\u0026#34;, \u0026#34;thomas\u0026#34;: \u0026#34;02283\u0026#34;, \u0026#34;fec\u0026#34;: [ \u0026#34;S4IA00129\u0026#34; ], \u0026#34;govtrack\u0026#34;: 412667, \u0026#34;opensecrets\u0026#34;: \u0026#34;N00035483\u0026#34;, \u0026#34;lis\u0026#34;: \u0026#34;S376\u0026#34; }, \u0026#34;name\u0026#34;: { \u0026#34;first\u0026#34;: \u0026#34;Joni\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Ernst\u0026#34;, \u0026#34;official_full\u0026#34;: \u0026#34;Joni Ernst\u0026#34; }, \u0026#34;bio\u0026#34;: { \u0026#34;gender\u0026#34;: \u0026#34;F\u0026#34;, \u0026#34;birthday\u0026#34;: \u0026#34;1970-07-01\u0026#34; }, \u0026#34;terms\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;sen\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;2015-01-06\u0026#34;, \u0026#34;end\u0026#34;: \u0026#34;2021-01-03\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;IA\u0026#34;, \u0026#34;class\u0026#34;: 2, \u0026#34;state_rank\u0026#34;: \u0026#34;junior\u0026#34;, \u0026#34;party\u0026#34;: \u0026#34;Republican\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://www.ernst.senate.gov\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;825 B\u0026amp;C Hart Senate Office Building Washington DC 20510\u0026#34;, \u0026#34;office\u0026#34;: \u0026#34;825 B\u0026amp;c Hart Senate Office Building\u0026#34;, \u0026#34;phone\u0026#34;: \u0026#34;202-224-3254\u0026#34; } ] }  query a attribute  $ jq \u0026#39;.name\u0026#39; example.json { \u0026#34;first\u0026#34;: \u0026#34;Joni\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Ernst\u0026#34;, \u0026#34;official_full\u0026#34;: \u0026#34;Joni Ernst\u0026#34; }  query nested attribute  $ jq \u0026#39;.name.first\u0026#39; example.json \u0026#34;Joni\u0026#34;  query a array  $ jq \u0026#39;.terms[0]\u0026#39; example.json { \u0026#34;type\u0026#34;: \u0026#34;sen\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;2015-01-06\u0026#34;, \u0026#34;end\u0026#34;: \u0026#34;2021-01-03\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;IA\u0026#34;, \u0026#34;class\u0026#34;: 2, \u0026#34;state_rank\u0026#34;: \u0026#34;junior\u0026#34;, \u0026#34;party\u0026#34;: \u0026#34;Republican\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://www.ernst.senate.gov\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;825 B\u0026amp;C Hart Senate Office Building Washington DC 20510\u0026#34;, \u0026#34;office\u0026#34;: \u0026#34;825 B\u0026amp;c Hart Senate Office Building\u0026#34;, \u0026#34;phone\u0026#34;: \u0026#34;202-224-3254\u0026#34; }  select(boolean_expression)  select(x) produces its input unchanged if x returns true for that input, and produces no output otherwise.\n$ jq \u0026#39;.terms[] | select(.class == 2)\u0026#39; example.json { \u0026#34;type\u0026#34;: \u0026#34;sen\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;2015-01-06\u0026#34;, \u0026#34;end\u0026#34;: \u0026#34;2021-01-03\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;IA\u0026#34;, \u0026#34;class\u0026#34;: 2, \u0026#34;state_rank\u0026#34;: \u0026#34;junior\u0026#34;, \u0026#34;party\u0026#34;: \u0026#34;Republican\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://www.ernst.senate.gov\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;825 B\u0026amp;C Hart Senate Office Building Washington DC 20510\u0026#34;, \u0026#34;office\u0026#34;: \u0026#34;825 B\u0026amp;c Hart Senate Office Building\u0026#34;, \u0026#34;phone\u0026#34;: \u0026#34;202-224-3254\u0026#34; } Notice: particular attribute such as numbers should use quotes\n to_entries, from_entries, with_entries  These functions convert between an object and an array of key-value pairs. If to_entries is passed an object, then for each k: v entry in the input, the output array includes {\u0026ldquo;key\u0026rdquo;: k, \u0026ldquo;value\u0026rdquo;: v}.\nfrom_entries does the opposite conversion, and with_entries(foo) is a shorthand for to_entries | map(foo) | from_entries, useful for doing some operation to all keys and values of an object. from_entries accepts key, Key, name, Name, value and Value as keys.\njq 'to_entries' Input\t{\u0026quot;a\u0026quot;: 1, \u0026quot;b\u0026quot;: 2} Output\t[{\u0026quot;key\u0026quot;:\u0026quot;a\u0026quot;, \u0026quot;value\u0026quot;:1}, {\u0026quot;key\u0026quot;:\u0026quot;b\u0026quot;, \u0026quot;value\u0026quot;:2}] jq 'from_entries' Input\t[{\u0026quot;key\u0026quot;:\u0026quot;a\u0026quot;, \u0026quot;value\u0026quot;:1}, {\u0026quot;key\u0026quot;:\u0026quot;b\u0026quot;, \u0026quot;value\u0026quot;:2}] Output\t{\u0026quot;a\u0026quot;: 1, \u0026quot;b\u0026quot;: 2} jq 'with_entries(.key |= \u0026quot;KEY_\u0026quot; + .)' Input\t{\u0026quot;a\u0026quot;: 1, \u0026quot;b\u0026quot;: 2} Output\t{\u0026quot;KEY_a\u0026quot;: 1, \u0026quot;KEY_b\u0026quot;: 2}  change field value  jq '.name=\u0026quot;1\u0026quot;|.resource=\u0026quot;2\u0026quot;' Input {\u0026quot;name\u0026quot;:\u0026quot;a\u0026quot;,\u0026quot;resource\u0026quot;:\u0026quot;b\u0026quot;} Ouput {\u0026quot;name\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;resource\u0026quot;:\u0026quot;2\u0026quot;}  show select fields  jq '.name,.resource' Input {\u0026quot;name\u0026quot;:\u0026quot;a\u0026quot;,\u0026quot;resource\u0026quot;:\u0026quot;b\u0026quot;,\u0026quot;type\u0026quot;:\u0026quot;c\u0026quot;} Output \u0026quot;a\u0026quot; \u0026quot;b\u0026quot;  delete field value  jq 'del(.name)' Input {\u0026quot;name\u0026quot;:\u0026quot;a\u0026quot;,\u0026quot;resource\u0026quot;:\u0026quot;b\u0026quot;,\u0026quot;type\u0026quot;:\u0026quot;c\u0026quot;} Output {\u0026quot;resource\u0026quot;:\u0026quot;b\u0026quot;,\u0026quot;type\u0026quot;:\u0026quot;c\u0026quot;}  change key field  jq '{\u0026quot;newkey\u0026quot;:.name,\u0026quot;newkey2\u0026quot;:.type}' Input {\u0026quot;name\u0026quot;:\u0026quot;a\u0026quot;,\u0026quot;resource\u0026quot;:\u0026quot;b\u0026quot;,\u0026quot;type\u0026quot;:\u0026quot;c\u0026quot;} Output {\u0026quot;newkey\u0026quot;:\u0026quot;a\u0026quot;,\u0026quot;newkey2\u0026quot;:\u0026quot;c\u0026quot;} "
},
{
	"uri": "http://mymneo.github.io/posts/behaviors-ext4-file-system-when-devicemapper-pool-is-full/",
	"title": "behaviors of ext4 file system when devicemapper pool is full",
	"tags": ["linux", "devicemapper", "docker"],
	"description": "",
	"content": "Backgroud  Our production system currently use docker to run all kinds of services. One day our clients reported that their service could not write down any log in the container and all the other containers which were started and worked well a few days ago also couldn\u0026rsquo;t. And the containers couldn\u0026rsquo;t be recovered. We logged in the malfunction machine, found that the thin pool used by devicemapper was full. At the same time there was some messages that dmesg reported telling the file system of containers became read-only.\nReason  Devicemapper is a COW storage model, that means no blocks are allocated if no data is produced. A container had 10G capacity as default. Now we assume that your thin pool\u0026rsquo;s size is 40G, and 4 containers writing log persistently and rapidly, the last 5 produce data very slowly. At some moment, the pool becomes full because of that 4 containers which generate log persistently and rapidly. And this time it triggers the condition we mentioned at the beginning of the article, all the 10 containers become read-only, we can\u0026rsquo;t recover them except we delete them.\n The reason why the conainer became read-only is that the error behavior of file system. When the pool is full, a request of allocating a block in thin pool will failed, that will raise an error to file system. The default hanlder to this kind of error of ext4 is to remount the file system read-only.\nPrevention  Add surveillance to thin pool used by devicemapper.\n"
},
{
	"uri": "http://mymneo.github.io/tags/devicemapper/",
	"title": "devicemapper",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/tags/docker/",
	"title": "docker",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/tags/kvm/",
	"title": "kvm",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/posts/kvm/",
	"title": "kvm virtual machine with vnc support",
	"tags": ["kvm", "linux"],
	"description": "",
	"content": "Install a KVM virtual machin with VNC support  Create a disk for VM  qemu-img create -f qcow2 \u0026lt;img path\u0026gt; \u0026lt;size\u0026gt;  Use virt-install install a VM  virt-install \\  --virt-type kvm \\  --name \u0026lt;name\u0026gt; \\  --cdrom=\u0026lt;cdrom iso\u0026gt; \\  --disk path=\u0026lt;disk path\u0026gt; \\  --network network=default \\  --graphics vnc,listen=0.0.0.0 \\  --noautoconsole \\  --os-type=\u0026lt;os type\u0026gt; \\  --os-variant=\u0026lt;os\u0026gt;  Show VNC port  virsh vncdisplay \u0026lt;domain name\u0026gt; VM Operations  Sometimes you need add For example:\nvirsh -c qemu:///system\n  Start VM  virsh start \u0026lt;domain name\u0026gt;  Stop VM  virsh destroy \u0026lt;domain name\u0026gt;  Delete VM  virsh undefined \u0026lt;domain name\u0026gt; "
},
{
	"uri": "http://mymneo.github.io/tags/cheatsheet/",
	"title": "cheatsheet",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/tags/find/",
	"title": "find",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/posts/find-cheatsheet/",
	"title": "find cheatsheet",
	"tags": ["linux", "find", "cheatsheet"],
	"description": "",
	"content": "Frequently used option of Find TEST    option description example     -name  find the file which name is filename find / -name \u0026ldquo;*.js\u0026rdquo;   -group  find the file belongs to group-name find / -group users   -user  find the file belongs to user-name find / -user root   -maxdepth  Descend at most levels to find find / -maxdepth 4   -empty find file is empty and is either a regular file or a directory find / -empty   -path  find file name matches shell pattern  find / -path \u0026ldquo;/sr*sc\u0026rdquo;   -perm  find file\u0026rsquo;s permission bits are exactly mode find / -perm 0664   -perm - find all of the permission bits mode are set for the file find / -perm -644   -perm / find any of the permission bits mode are set for the file find / -perm /644   -regex  find file name matches regular expression  find / -regex \u0026ldquo;.*bar\u0026rdquo;   -size n[cwbkMG] find file uses n units of space, rounding up. The following suffixes can be used: b for 512-byte blocks (this is the default if no suffix is used), c for bytes, w for two-byte words, k for Kilobytes (units of 1024 bytes), M for Megabytes (units of 1048576 bytes), G for Gigabytes (units of 1073741824 bytes) find / -size 1G   -type c find file is of type c: b block (buffered) special,c character (unbuffered) special, d directory, p named pipe (FIFO), f regular file, l symbolic link; this is never true if the -L option or the -follow option is in effect, unless the symbolic link is broken. If you want to search for symbolic links when -L is in effect, use -xtype, s socket find / -type d    ACTION    option description     -delete Delete files   -exec  Execute    -fprint  print the full file name into file    -print print the full file name on the standard output, followed by a newline   -prune if the file is a directory, do not descend into it    "
},
{
	"uri": "http://mymneo.github.io/posts/lvm-thin-pool-cheatsheet/",
	"title": "lvm thin pool cheatsheet",
	"tags": ["linux", "devicemapper", "docker", "cheatsheet"],
	"description": "",
	"content": " We use devicemapper as Docker storage driver, sometime any of the meta or data pool is full. We have to extend the pool\n  Single step thin pool LV creation  lvcreate --type thin-pool --poolmetadata \u0026lt;meta size\u0026gt; -L \u0026lt;pool size\u0026gt; \u0026lt;pool name\u0026gt;  Manually manage free data space of thin pool LV  lvextend -L \u0026lt;size\u0026gt; \u0026lt;pool name\u0026gt;  Manually manage free metadata space of a thin pool LV  lvs -oname,size,data_percent,metadata_percent # show the available metadat space in a thin pool LV lvextend --poolmetadatasize \u0026lt;size\u0026gt; \u0026lt;pool name\u0026gt; Metadata space exhaustion  Metadata space exhaustion can lead to inconsistent thin pool metadata and inconsistent file systems, so the response requires offline checking and repair.\n  Deactivate the thin pool LV, or reboot the system if this is not possible. Repair thin pool with lvconvert --repair. See \u0026ldquo;Metadata check and repair\u0026rdquo;. Extend pool metadata space with lvextend --poolmetadatasize. Check and repair file system with fsck.  Metadata check and repair Repair performs the following steps:\n Creates a new, repaired copy of the metadata.lvconvert runs the thin_repair command to read damaged metadata from the existing pool metadata LV, and writes a new repaired copy to the VG\u0026rsquo;s pmspare LV. Replaces the thin pool metadata LV. If step 1 is successful, the thin pool metadata LV is replaced with the pmspare LV containing the corrected metadata. The previous thin pool metadata LV, containing the damaged metadata, becomes visible with the new name ThinPoolLV_tmetaN (where N is 0,1,\u0026hellip;).  If the repair works, the thin pool LV and its thin LVs can be activated, and the LV containing the damaged thin pool metadata can be removed. It may be useful to move the new metadata LV (previously pmspare) to a better PV.\nIf the repair does not work, the thin pool LV and its thin LVs are lost.\nIf metadata is manually restored with thin_repair directly, the pool metadata LV can be manually swapped with another LV containing new metadata: lvconvert --thinpool VG/ThinPoolLV --poolmetadata VG/NewThinMetaLV\n"
},
{
	"uri": "http://mymneo.github.io/tags/filesystem/",
	"title": "filesystem",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/posts/resize-disk/",
	"title": "resize disk",
	"tags": ["linux", "filesystem", "cheatsheet"],
	"description": "",
	"content": "Shrink a disk  If the partition the file system is on is currently mounted, unmount it  umount /dev/disk  Run fsck on the umounted file system  e2fsck -f /dev/disk  Shrink the file system with the resize2fs /dev/fdisk size  resize2fs /dev/disk size  Use fdisk to modify the partition table information  fdisk /dev/disk  Mount the disk  mount /dev/disk target "
},
{
	"uri": "http://mymneo.github.io/tags/shell/",
	"title": "shell",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/posts/shell-cheatsheet/",
	"title": "Shell Cheatsheet",
	"tags": ["linux", "shell", "cheatsheet"],
	"description": "",
	"content": " Checking if string does or not contain other string  Use \u0026lsquo;=\u0026rsquo; or \u0026lsquo;!=\u0026rsquo;\nif [[ ${testmystring} = *\u0026#34;c0\u0026#34;* ]];then # testmystring does contain c0 fi if [[ ${testmystring} != *\u0026#34;c0\u0026#34;* ]];then # testmystring does not contain c0 fi "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/reverse-bits/",
	"title": "Reverse Bits",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Reverse bits of a given 32 bits unsigned integer.\nFor example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).\nFollow up:\nIf this function is called many times, how would you optimize it?\n Analysis: 与counting bit类似,divide and conquer,先2位2位swap,然后4位4位swap\nTime and space complexity: time: $\\Theta (1)$\nspace: $\\Theta (1)$\nCode: class Solution { public: uint32_t reverseBits(uint32_t n) { n = (n \u0026gt;\u0026gt; 16) | (n \u0026lt;\u0026lt; 16); n = ((n \u0026amp; 0xff00ff00) \u0026gt;\u0026gt; 8) | ((n \u0026amp; 0x00ff00ff) \u0026lt;\u0026lt; 8); n = ((n \u0026amp; 0xf0f0f0f0) \u0026gt;\u0026gt; 4) | ((n \u0026amp; 0x0f0f0f0f) \u0026lt;\u0026lt; 4); n = ((n \u0026amp; 0xcccccccc) \u0026gt;\u0026gt; 2) | ((n \u0026amp; 0x33333333) \u0026lt;\u0026lt; 2); n = ((n \u0026amp; 0xaaaaaaaa) \u0026gt;\u0026gt; 1) | ((n \u0026amp; 0x55555555) \u0026lt;\u0026lt; 1); return n; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/read-n-characters-given-read4/",
	"title": "Read N Characters Given Read4",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " The API: int read4(char *buf) reads 4 characters at a time from a file.\nThe return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.\nBy using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.\nNote: The read function will only be called once for each test case.\n Analysis: API实现,看代码就可以了\nTime and space complexity: Code: class Solution { public: /** * @param buf Destination buffer * @param n Maximum number of characters to read * @return The number of characters read */ int read(char *buf, int n) { int num = 0; while (n \u0026gt; 0) { int tmp = min(read4(buf), n); num += tmp; buf += tmp; if (tmp \u0026lt; 4) { break; } n -= 4; } return num; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/valid-parentheses/",
	"title": "Valid Parentheses",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\nThe brackets must close in the correct order, \u0026quot;()\u0026quot; and \u0026quot;()[]{}\u0026quot; are all valid but \u0026quot;(]\u0026quot; and \u0026quot;([)]\u0026quot; are not.\n Analysis: 经典的用stack解决的问题\nTime and space complexity: time: $\\Theta (n)$\nspace: $\\Theta (n)$\nCode: class Solution { public: bool isValid(string s) { unordered_map\u0026lt;char, char\u0026gt; table { {\u0026#39;(\u0026#39;, \u0026#39;)\u0026#39;}, {\u0026#39;[\u0026#39;, \u0026#39;]\u0026#39;}, {\u0026#39;{\u0026#39;, \u0026#39;}\u0026#39;}, }; stack\u0026lt;char\u0026gt; frame; for (char\u0026amp; c : s) { switch(c) { case \u0026#39;(\u0026#39;: case \u0026#39;[\u0026#39;: case \u0026#39;{\u0026#39;: { frame.push(c); break; } case \u0026#39;)\u0026#39;: case \u0026#39;]\u0026#39;: case \u0026#39;}\u0026#39;: { if (!frame.empty() \u0026amp;\u0026amp; table[frame.top()] == c) { frame.pop(); break; } else { return false; } } } } return frame.empty(); } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/remove-nth-node-from-end-of-list/",
	"title": "Remove Nth Node From End of List",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given a linked list, remove the nth node from the end of list and return its head.\nFor example,\nGiven linked list: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5, and n = 2.\nAfter removing the second node from the end, the linked list becomes 1-\u0026gt;2-\u0026gt;3-\u0026gt;5.\nNote:\nGiven n will always be valid. Try to do this in one pass.\n Analysis: 双指针,类似n大小滑动窗口\nTime and space complexity: time: $\\Theta (n)$\nCode: class Solution { public: ListNode *removeNthFromEnd(ListNode *head, int n) { ListNode **t1 = \u0026amp;head, *t2 = head; for (int i = 1; i \u0026lt; n; ++i) { t2 = t2-\u0026gt;next; } while (t2-\u0026gt;next != NULL) { t1 = \u0026amp;((*t1)-\u0026gt;next); t2 = t2-\u0026gt;next; } *t1 = (*t1)-\u0026gt;next; return head; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/isomorphic-strings/",
	"title": "Isomorphic Strings",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given two strings s and t, determine if they are isomorphic.\nTwo strings are isomorphic if the characters in s can be replaced to get t.\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.\nFor example,\nGiven \u0026quot;egg\u0026quot;, \u0026quot;add\u0026quot;, return true.\nGiven \u0026quot;foo\u0026quot;, \u0026quot;bar\u0026quot;, return false.\nGiven \u0026quot;paper\u0026quot;, \u0026quot;title\u0026quot;, return true.\nNote:\nYou may assume both s and t have the same length.\n Analysis: 用2个map来做s-\u0026gt;t和t-\u0026gt;s的字符映射,如果有一个不满足就是为false\nTime and space complexity: time: $\\Theta (n)$\nspace: $\\Theta (n)$\nCode: class Solution { public: bool isIsomorphic(string s, string t) { if (s.length() != t.length()) { return false; } unordered_map\u0026lt;char, char\u0026gt; sm, tm; int size = s.length(); for (int i = 0; i \u0026lt; size; ++i) { if (sm[s[i]] == \u0026#39;\\0\u0026#39; \u0026amp;\u0026amp; tm[t[i]] == \u0026#39;\\0\u0026#39;) { sm[s[i]] = t[i]; tm[t[i]] = s[i]; continue; } if (sm[s[i]] == t[i] \u0026amp;\u0026amp; tm[t[i]] == s[i]) { continue; } return false; } return true; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/bulls-and-cows/",
	"title": "Bulls and Cows",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called \u0026ldquo;bulls\u0026rdquo;) and how many digits match the secret number but locate in the wrong position (called \u0026ldquo;cows\u0026rdquo;). Your friend will use successive guesses and hints to eventually derive the secret number.\nFor example:\n Secret number: \u0026quot;1807\u0026quot; Friend's guess: \u0026quot;7810\u0026quot;  Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.) Write a function to return a hint according to the secret number and friend\u0026rsquo;s guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return \u0026quot;1A3B\u0026quot;.\nPlease note that both secret number and friend\u0026rsquo;s guess may contain duplicate digits, for example:\n Secret number: \u0026quot;1123\u0026quot; Friend's guess: \u0026quot;0111\u0026quot;  In this case, the 1st 1 in friend\u0026rsquo;s guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return \u0026quot;1A1B\u0026quot;. You may assume that the secret number and your friend\u0026rsquo;s guess only contain digits, and their lengths are always equal.\n Analysis: 分别记录secret和guess出现的差值,如果有差值,那么就是一个cow\nTime and space complexity: time: $\\Theta (n)$\nspace: $\\Theta (n)$\nCode: class Solution { public: string getHint(string secret, string guess) { int size = secret.size(); int bull = 0, cow = 0; unordered_map\u0026lt;char, int\u0026gt; record; for (int i = 0; i \u0026lt; size; ++i) { if (secret[i] == guess[i]) { ++bull; } else { if (record[secret[i]] \u0026gt; 0) { ++cow; } if (record[guess[i]] \u0026lt; 0) { ++cow; } --record[secret[i]]; ++record[guess[i]]; } } stringstream result; result \u0026lt;\u0026lt; bull \u0026lt;\u0026lt; \u0026#39;A\u0026#39; \u0026lt;\u0026lt; cow \u0026lt;\u0026lt; \u0026#39;B\u0026#39;; return result.str(); } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/rectangle-area/",
	"title": "Rectangle Area",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Find the total area covered by two rectilinear rectangles in a 2D plane.\nEach rectangle is defined by its bottom left corner and top right corner as shown in the figure.\n Assume that the total area is never beyond the maximum possible value of int.\n  Analysis: 分cross和non-cross2种情况\nTime and space complexity: Code: class Solution { public: int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) { int w1 = abs(A - C); int h1 = abs(B - D); int w2 = abs(E - G); int h2 = abs(H - F); int w3 = abs(min(A, E) - max(C, G)); int h3 = abs(min(B, F) - max(D, H)); // cross  if (w1 + w2 \u0026gt;= w3 \u0026amp;\u0026amp; h1 + h2 \u0026gt;= h3) { return (w1 * h1 + w2 * h2) - (w1 + w2 - w3) * (h1 + h2 - h3); } return w1 * h1 + w2 * h2; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/contains-duplicate-ii/",
	"title": "Contains Duplicate II",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.\n Analysis: 长度为k的滑动窗口,用map来记录数字出现的次数\nTime and space complexity: time: $\\Theta (n)$\nspace: $\\Theta (n)$\nCode: class Solution { public: bool containsNearbyDuplicate(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int size = nums.size(); unordered_map\u0026lt;int, int\u0026gt; record; for (int i = 0; i \u0026lt; size; ++i) { if (i \u0026gt; k) { --record[nums[i - k - 1]]; } ++record[nums[i]]; if (record[nums[i]] \u0026gt; 1) { return true; } } return false; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/merge-sorted-array/",
	"title": "Merge Sorted Array",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.\nNote: You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.\n Analysis: 题目的意思是不要用额外空间,为了避免overwrite原始数据,从m+n的位置开始写,逆序遍历2个array,选择最大的那个填到对应的位置\nTime and space complexity: time: $\\Theta (m+n)$\nCode: class Solution { public: void merge(vector\u0026lt;int\u0026gt;\u0026amp; nums1, int m, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int n) { int size = m + n; int i, j; for (i = m - 1, j = n - 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; ) { if (nums1[i] \u0026gt; nums2[j]) { nums1[--size] = nums1[i]; --i; } else { nums1[--size] = nums2[j]; --j; } } while (i \u0026gt;= 0) { nums1[--size] = nums1[i--]; } while (j \u0026gt;= 0) { nums1[--size] = nums2[j--]; } } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/intersection-of-two-linked-lists/",
	"title": "Intersection of Two Linked Lists",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Write a program to find the node at which the intersection of two singly linked lists begins.\nFor example, the following two linked lists:\n A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3  begin to intersect at node c1.\nNotes:\n If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory.   Analysis: 一种方式,原理跟快慢指针找环是一个道理,将一个list的尾部加到另外一个list的头部,找到交叉部分,然后根据交叉部分来找到相交部分.\n另外一种方式是,交叉遍历,如代码所示\nTime and space complexity: time: $\\Theta (n)$\nspace: $\\Theta (1)$\nCode: class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *getIntersectionNode(ListNode * headA, ListNode * headB) { ListNode *p1 = headA; ListNode *p2 = headB; if (p1 == NULL || p2 == NULL) return NULL; while (p1 != NULL \u0026amp;\u0026amp; p2 != NULL \u0026amp;\u0026amp; p1 != p2) { p1 = p1-\u0026gt;next; p2 = p2-\u0026gt;next; //  // Any time they collide or reach end together without colliding  // then return any one of the pointers.  //  if (p1 == p2) return p1 //  // If one of them reaches the end earlier then reuse it  // by moving it to the beginning of other list.  // Once both of them go through reassigning,  // they will be equidistant from the collision point.  //  if (p1 == NULL) p1 = headB; if (p2 == NULL) p2 = headA; } return p1; } } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/implement-stack-using-queues/",
	"title": "Implement Stack using Queues",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Implement the following operations of a stack using queues.\n push(x) \u0026ndash; Push element x onto stack. pop() \u0026ndash; Removes the element on top of the stack. top() \u0026ndash; Get the top element. empty() \u0026ndash; Return whether the stack is empty.  Notes:\n You must use only standard operations of a queue \u0026ndash; which means only push to back, peek/pop from front, size, and is empty operations are valid. Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).   Analysis: 双队列\n push的时候记录最后一次push的元素,这样top的时候就可以迅速直到top的结果 pop,弹出队列元素到新队列里面,剩余最后一个元素的时候停止 top,返回对应变量 empty,队列的empty  Time and space complexity: time:\npush $\\Theta (1)$\npop $\\Theta (n)$\ntop $\\Theta (1)$\nempty $\\Theta (1)$\nCode: class Stack { public: // Push element x onto stack.  void push(int x) { mock.push(x); } // Removes the element on top of the stack.  void pop() { std::queue\u0026lt;int\u0026gt; tmp; while (mock.size() \u0026gt; 1) { tmp.push(mock.front()); mock.pop(); } mock.swap(tmp); } // Get the top element.  int top() { return mock.back(); } // Return whether the stack is empty.  bool empty() { return mock.empty(); } private: std::queue\u0026lt;int\u0026gt; mock; }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/valid-sudoku/",
	"title": "Valid Sudoku",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.\nThe Sudoku board could be partially filled, where empty cells are filled with the character \u0026lsquo;.'.\nA partially filled sudoku which is valid.\nNote:\nA valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.\n Analysis: Sudoku的要求,每个格子只能有1-9且只能出现一次\nTime and space complexity: Code: class Solution { public: bool isValidSudoku(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board) { unordered_map\u0026lt;char, int\u0026gt; record; //row  for (int i = 0; i \u0026lt; 9; ++i) { record.clear(); for (int j = 0; j \u0026lt; 9; ++j) { if (!pass(record, board, i, j)) { return false; } } } //column  for (int j = 0; j \u0026lt; 9; ++j) { record.clear(); for (int i = 0; i \u0026lt; 9; ++i) { if (!pass(record, board, i, j)) { return false; } } } //cell  for (int k = 0; k \u0026lt; 9; ++k) { record.clear(); int rowBegin = (k / 3) * 3; int columnBegin = (k % 3) * 3; for (int i = rowBegin; i \u0026lt; rowBegin + 3; ++i) { for (int j = columnBegin; j \u0026lt; columnBegin + 3; ++j) { if (!pass(record, board, i , j)) { return false; } } } } return true; } bool pass(unordered_map\u0026lt;char, int\u0026gt;\u0026amp; record, vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, int i, int j) { record[board[i][j]]++; if (board[i][j] != \u0026#39;.\u0026#39; \u0026amp;\u0026amp; record[board[i][j]] \u0026gt; 1) { return false; } return true; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/minimum-depth-of-binary-tree/",
	"title": "Minimum Depth of Binary Tree",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n Analysis: DFS或者BFS遍历\nTime and space complexity: time: $\\Theta (n)$\nCode: class Solution { public: int minDepth(TreeNode *root) { if(!root) return 0; if(!root-\u0026gt;left) return 1 + minDepth(root-\u0026gt;right); if(!root-\u0026gt;right) return 1 + minDepth(root-\u0026gt;left); return 1 + min(minDepth(root-\u0026gt;left), minDepth(root-\u0026gt;right)); } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/paint-fence/",
	"title": "Paint Fence",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " There is a fence with n posts, each post can be painted with one of the k colors.\nYou have to paint all the posts such that no more than two adjacent fence posts have the same color.\nReturn the total number of ways you can paint the fence.\nNote:\nn and k are non-negative integers.\n Analysis: 分2种情况考虑:\n 最后2个fences的color一样,这样就有(k-1)*f(n-2) 最后2个fences的color不一样,这样就有(k-1)*f(n-1)  Time and space complexity: time: $\\Theta (n)$\nspace: $\\Theta (1)$\nCode: class Solution { public: int numWays(int n, int k) { if (n == 0 || k == 0 || (k == 1 \u0026amp;\u0026amp; n \u0026gt; 2)) { return 0; } int w1 = k, w2 = k * k; if (n == 1) { return w1; } if (n == 2) { return w2; } for (int i = 3; i \u0026lt;= n; ++i) { int w3 = (k - 1) * (w1 + w2); w1 = w2; w2 = w3; } return w2; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/path-sum/",
	"title": "Path Sum",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\nFor example:\nGiven the below binary tree and sum = 22,\n  5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1  return true, as there exist a root-to-leaf path 5-\u0026gt;4-\u0026gt;11-\u0026gt;2 which sum is 22.\n Analysis: DFS或者BFS遍历,附带参数为当前的sum值\nTime and space complexity: time: $\\Theta (n)$\nCode: class Solution { public: bool hasPathSum(TreeNode* root, int sum) { return root ? pathSum(root, 0, sum) : false; } bool pathSum(TreeNode* node, int sum, int want) { if (!node) { return false; } if (!node-\u0026gt;left \u0026amp;\u0026amp; !node-\u0026gt;right) { return (sum + node-\u0026gt;val) == want; } return pathSum(node-\u0026gt;left, sum + node-\u0026gt;val, want) || pathSum(node-\u0026gt;right, sum + node-\u0026gt;val, want); } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/group-shifted-strings/",
	"title": "Group Shifted Strings",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given a string, we can \u0026ldquo;shift\u0026rdquo; each of its letter to its successive letter, for example: \u0026quot;abc\u0026quot; -\u0026gt; \u0026quot;bcd\u0026quot;. We can keep \u0026ldquo;shifting\u0026rdquo; which forms the sequence:\n \u0026quot;abc\u0026quot; -\u0026gt; \u0026quot;bcd\u0026quot; -\u0026gt; ... -\u0026gt; \u0026quot;xyz\u0026quot;  Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence.\nFor example, given: [\u0026quot;abc\u0026quot;, \u0026quot;bcd\u0026quot;, \u0026quot;acef\u0026quot;, \u0026quot;xyz\u0026quot;, \u0026quot;az\u0026quot;, \u0026quot;ba\u0026quot;, \u0026quot;a\u0026quot;, \u0026quot;z\u0026quot;], Return:\n [ [\u0026quot;abc\u0026quot;,\u0026quot;bcd\u0026quot;,\u0026quot;xyz\u0026quot;], [\u0026quot;az\u0026quot;,\u0026quot;ba\u0026quot;], [\u0026quot;acef\u0026quot;], [\u0026quot;a\u0026quot;,\u0026quot;z\u0026quot;] ]  Note: For the return value, each inner list\u0026rsquo;s elements must follow the lexicographic order.\n Analysis: 根据shift的pattern来当做key,string作为value,这样相同的shift的pattern就会是同一组values,然后排序一下\nTime and space complexity: time: $\\Theta (nk)$,k是字符平均长度\nspace: $\\Theta (n)$\nCode: class Solution { public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; groupStrings(vector\u0026lt;string\u0026gt;\u0026amp; strings) { unordered_map\u0026lt;string, vector\u0026lt;string\u0026gt;\u0026gt; record; for (string\u0026amp; s : strings) { record[shift(s)].push_back(s); } vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; result; for (auto it : record) { vector\u0026lt;string\u0026gt; group = it.second; sort(group.begin(), group.end()); result.push_back(group); } return result; } string shift(string\u0026amp; s) { string r; int size = s.length(); for (int i = 1; i \u0026lt; size; ++i) { int diff = s[i] - s[i - 1]; if (diff \u0026lt; 0) { diff += 26; } r.push_back(\u0026#39;a\u0026#39; + diff); } return r; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/palindrome-number/",
	"title": "Palindrome Number",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Determine whether an integer is a palindrome. Do this without extra space.\n Analysis: 利用回文数的特点:逆序还是原来的数解决,注意溢出问题,为了防止溢出,只需要算一半的数字即可\nTime and space complexity: space: $\\Theta (1)$\nCode: class Solution { public: bool isPalindrome(int x) { if (x\u0026lt;0 || (x!=0 \u0026amp;\u0026amp; x%10==0)) return false; int rev = 0; while (x\u0026gt;rev){ rev = rev*10 + x%10; x = x/10; } return (x==rev || x==rev/10); }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/pascal-s-triangle-ii/",
	"title": "Pascal&#39;s Triangle II",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given an index k, return the kth row of the Pascal\u0026rsquo;s triangle.\nFor example, given k = 3, Return [1,3,3,1].\nNote:\nCould you optimize your algorithm to use only O(k) extra space?\n Analysis: 思路和pascal\u0026rsquo;s triangle一样\nTime and space complexity: time: $\\Theta (k^2)$\nspace: $\\Theta (k)$\nCode: class Solution { public: vector\u0026lt;int\u0026gt; getRow(int rowIndex) { vector\u0026lt;int\u0026gt; A(rowIndex+1, 0); A[0] = 1; for(int i=1; i\u0026lt;rowIndex+1; i++) for(int j=i; j\u0026gt;=1; j--) A[j] += A[j-1]; return A; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/binary-tree-level-order-traversal/",
	"title": "Binary Tree Level Order Traversal",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given a binary tree, return the level order traversal of its nodes\u0026rsquo; values. (ie, from left to right, level by level).\nFor example:\nGiven binary tree {3,9,20,#,#,15,7},\n  3 / \\ 9 20 / \\ 15 7  return its level order traversal as:\n [ [3], [9,20], [15,7] ] Analysis: level遍历\nTime and space complexity: time: $\\Theta (n)$\nCode: class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrderBottom(TreeNode* root) { DFS(root, 0); return res; } private: void DFS(TreeNode* root, int level) { if (root == NULL) return; if (level == res.size()) {// The level does not exist in output  res.push_back(vector\u0026lt;int\u0026gt;()); // Create a new level  } res[level].push_back(root-\u0026gt;val); // Add the current value to its level  DFS(root-\u0026gt;left, level+1); // Go to the next level  DFS(root-\u0026gt;right,level+1); } private: vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; res; }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/factorial-trailing-zeroes/",
	"title": "Factorial Trailing Zeroes",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given an integer n, return the number of trailing zeroes in n!.\nNote: Your solution should be in logarithmic time complexity.\n Analysis: 因为2比较多,0的个数由5的个数决定,需要注意的是5的power的数字,会包含5的个数更多,不停的除以5,并把商加起来为0的个数\nTime and space complexity: time: $\\Theta(log_5(n))$\nCode: class Solution { public: int trailingZeroes(int n) { int result = 0; while (n) { n /= 5; result += n; } return result; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/pascal-s-triangle/",
	"title": "Pascal&#39;s Triangle",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given numRows, generate the first numRows of Pascal\u0026rsquo;s triangle.\nFor example, given numRows = 5,\nReturn\n [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] Analysis: 类似dp, 对于每一个新行,现push 1,然后根据上一行从第二个元素开始,把上一行的当前位置的元素和它前面的元素加一起,为这个新行该位置的值\nTime and space complexity: Code: class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; generate(int numRows) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; r(numRows); for (int i = 0; i \u0026lt; numRows; i++) { r[i].resize(i + 1); r[i][0] = r[i][i] = 1; for (int j = 1; j \u0026lt; i; j++) r[i][j] = r[i - 1][j - 1] + r[i - 1][j]; } return r; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/remove-duplicates-from-sorted-array/",
	"title": "Remove Duplicates from Sorted Array",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.\nDo not allocate extra space for another array, you must do this in place with constant memory.\nFor example,\nGiven input array nums = [1,1,2],\nYour function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn\u0026rsquo;t matter what you leave beyond the new length.\n Analysis: 还是去重复的思路\nTime and space complexity: time: $\\Theta (n)$\nCode: class Solution { public: int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (!nums.size()) { return 0; } int pos = -1; int last = nums.front() - 1; for (int\u0026amp; n : nums) { if (last != n) { nums[++pos] = n; last = n; } } return pos + 1; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/power-of-four/",
	"title": "Power of Four",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given an integer (signed 32 bits), write a function to check whether it is a power of 4.\nExample:\nGiven num = 16, return true. Given num = 5, return false.\nFollow up:\nCould you solve it without loops/recursion?\n Analysis: power of 4一定是power of 2,所以先用power of 2 的验证方法来验证,然后处理特例的情况,例如\n2 -\u0026gt; 10 # 10 \u0026amp; 01 = 0 8 -\u0026gt; 1000 # 1000 \u0026amp; 0101 = 0 32 -\u0026gt; 100000 # 100000 \u0026amp; 010101 = 0 是power of 2的数字再与0x55555555作and,如果不为0,就是power of 4\nTime and space complexity: time: $\\Theta (1)$\nCode: class Solution { public: bool isPowerOfFour(int num) { // first we check if the number is power of two, then we check the 1 whether is located  // at odd position, because 4 -\u0026gt; 100, 16 -\u0026gt; 10000  return num \u0026gt; 0 \u0026amp;\u0026amp; (num \u0026amp; (num - 1)) == 0 \u0026amp;\u0026amp; (num \u0026amp; 0x55555555) == num; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/plus-one/",
	"title": "Plus One",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given a non-negative number represented as an array of digits, plus one to the number.\nThe digits are stored such that the most significant digit is at the head of the list.\n Analysis: 逆向遍历,如果当前数字是9,那么变为0,如果不是9就把该数字+1,如果全是9的话,需要把第一位变成1,然后多加一个0\nTime and space complexity: time: $\\Theta (n)$\nCode: class Solution { public: vector\u0026lt;int\u0026gt; plusOne(vector\u0026lt;int\u0026gt;\u0026amp; digits) { int n = digits.size(); for (int i = n - 1; i \u0026gt;= 0; --i) { if (digits[i] == 9) { digits[i] = 0; } else { digits[i]++; return; } } digits[0] =1; digits.push_back(0); } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/remove-element/",
	"title": "Remove Element",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given an array and a value, remove all instances of that value in place and return the new length.\nDo not allocate extra space for another array, you must do this in place with constant memory.\nThe order of elements can be changed. It doesn\u0026rsquo;t matter what you leave beyond the new length.\nExample:\nGiven input array nums = [3,2,2,3], val = 3\nYour function should return length = 2, with the first two elements of nums being 2.\n Analysis: 跟去重复数字一个原理.\nTime and space complexity: time: $\\Theta (n)$\nCode: class Solution { public: int removeElement(vector\u0026lt;int\u0026gt;\u0026amp; nums, int val) { int pos = -1; for (int\u0026amp; n : nums) { if (n != val) { nums[++pos] = n; } } return pos + 1; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/binary-tree-level-order-traversal-ii/",
	"title": "Binary Tree Level Order Traversal II",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given a binary tree, return the bottom-up level order traversal of its nodes\u0026rsquo; values. (ie, from left to \u0026gt;right, level by level from leaf to root).\nFor example:\nGiven binary tree {3,9,20,#,#,15,7},\n  3 / \\ 9 20 / \\ 15 7  return its bottom-up level order traversal as:\n [ [15,7], [9,20], [3] ] Analysis: level遍历,最后reverse\nTime and space complexity: time: $\\Theta (n)$\nCode: class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrderBottom(TreeNode* root) { DFS(root, 0); return vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; (res.rbegin(), res.rend()); } private: void DFS(TreeNode* root, int level) { if (root == NULL) return; if (level == res.size()) {// The level does not exist in output  res.push_back(vector\u0026lt;int\u0026gt;()); // Create a new level  } res[level].push_back(root-\u0026gt;val); // Add the current value to its level  DFS(root-\u0026gt;left, level+1); // Go to the next level  DFS(root-\u0026gt;right,level+1); } private: vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; res; }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/implement-queue-using-stacks/",
	"title": "Implement Queue using Stacks",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Implement the following operations of a queue using stacks.\n push(x) \u0026ndash; Push element x to the back of queue. pop() \u0026ndash; Removes the element from in front of queue. peek() \u0026ndash; Get the front element. empty() \u0026ndash; Return whether the queue is empty.  Notes:\n You must use only standard operations of a stack \u0026ndash; which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard \u0026gt;operations of a stack. You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).   Analysis:  push,正常的方式push进去,如果stack为空的时候就记录第一入栈的数,该数值用来记录peek需要的值 pop,取栈顶值放到新的栈中直到stack的元素只剩下一个,退栈的时候记录peek的值 peek,返回peek值 empty,返回stack的empty  Time and space complexity: time:\npush $\\Theta (1)$\npop $\\Theta (n)$\npeek $\\Theta (1)$\nempty $\\Theta (1)$\nCode: class Queue { public: // Push element x to the back of queue.  void push(int x) { if (mock.empty()) { top = x; } mock.push(x); } // Removes the element from in front of queue.  void pop(void) { std::stack\u0026lt;int\u0026gt; tmp; while (mock.size() \u0026gt; 1) { tmp.push(mock.top()); mock.pop(); top = tmp.top(); } mock.pop(); while (!tmp.empty()) { mock.push(tmp.top()); tmp.pop(); } } // Get the front element.  int peek(void) { return top; } // Return whether the queue is empty.  bool empty(void) { return mock.empty(); } private: std::stack\u0026lt;int\u0026gt; mock; int top; }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/symmetric-tree/",
	"title": "Symmetric Tree",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\nFor example, this binary tree is symmetric:\n  1 / \\ 2 2 / \\ / \\ 3 4 4 3   But the following is not:\n   1 / \\ 2 2 \\ \\ 3 3  Note: Bonus points if you could solve it both recursively and iteratively.\n Analysis: 根据example,可以看出对称的位置是left-\u0026gt;left和right-\u0026gt;right,left-\u0026gt;right和right-\u0026gt;left,递归调用,检测每个子树是否为对称.\nTime and space complexity: time: $\\Theta (n)$\nCode: class Solution { public: bool isSymmetric(TreeNode* root) { if (!root) { return true; } return subTreeSymmetric(root-\u0026gt;left, root-\u0026gt;right); } private: bool subTreeSymmetric(TreeNode* left, TreeNode* right) { if (!left \u0026amp;\u0026amp; !right) { return true; } if (!left \u0026amp;\u0026amp; right) { return false; } if (left \u0026amp;\u0026amp; !right) { return false; } if (left \u0026amp;\u0026amp; right \u0026amp;\u0026amp; left-\u0026gt;val != right-\u0026gt;val) { return false; } return subTreeSymmetric(left-\u0026gt;left, right-\u0026gt;right) \u0026amp;\u0026amp; subTreeSymmetric(left-\u0026gt;right, right-\u0026gt;left); } }; iterative:\nclass Solution { public: bool isSymmetric(TreeNode *root) { TreeNode *left, *right; if (!root) return true; queue\u0026lt;TreeNode*\u0026gt; q1, q2; q1.push(root-\u0026gt;left); q2.push(root-\u0026gt;right); while (!q1.empty() \u0026amp;\u0026amp; !q2.empty()){ left = q1.front(); q1.pop(); right = q2.front(); q2.pop(); if (NULL == left \u0026amp;\u0026amp; NULL == right) continue; if (NULL == left || NULL == right) return false; if (left-\u0026gt;val != right-\u0026gt;val) return false; q1.push(left-\u0026gt;left); q1.push(left-\u0026gt;right); q2.push(right-\u0026gt;right); q2.push(right-\u0026gt;left); } return true; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/balanced-binary-tree/",
	"title": "Balanced Binary Tree",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given a binary tree, determine if it is height-balanced.\nFor this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two \u0026gt;subtrees of every node never differ by more than 1.\n Analysis: DFS遍历树,给每个节点一个depth值,检查左右子树的的depth值是否相差为1\nTime and space complexity: time: $\\Theta (n)$\nCode: class Solution { public: bool isBalanced(TreeNode* root) { bool result = true; Depth(root, result); return result; } private: int Depth(TreeNode* node, bool\u0026amp; result) { if (!node) { return 0; } int leftDepth = Depth(node-\u0026gt;left, result); int rightDepth = Depth(node-\u0026gt;right, result); result \u0026amp;= std::abs(leftDepth - rightDepth) \u0026lt;= 1; return std::max(leftDepth, rightDepth) + 1; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/house-robber/",
	"title": "House Robber",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\n Analysis: 1d DP问题\nformula:\ndp[i] = max(dp[i - 2] + data[i], dp[i - 1])\nTime and space complexity: time: $\\Theta (n)$\nspace: $\\Theta (n)$\noptimized $\\Theta (1)$\nCode: class Solution { public: int rob(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (nums.size() == 0) { return 0; } std::vector\u0026lt;int\u0026gt; dp(nums.size() + 1, 0); dp[0] = 0; for (int i = 0; i \u0026lt; (int) nums.size(); ++i) { dp[i + 1] = std::max(dp[i], (i \u0026gt; 1 ? dp[i - 1] : 0) + nums[i]); } return dp.back(); } }; optimized:\nclass Solution { public: int rob(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(), pre = 0, cur = 0; for (int i = 0; i \u0026lt; n; i++) { int temp = max(pre + nums[i], cur); pre = cur; cur = temp; } return cur; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/closest-binary-search-tree-value/",
	"title": "Closest Binary Search Tree Value",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.\n  Note: Given target value is a floating point. You are guaranteed to have only one unique value in the BST that is closest to the target.\n Analysis: 先判断target的值是在哪个分支,然后再用该分支的值与当前的root的值相比,看哪个值更接近target\nTime and space complexity: time: $\\Theta (log (n))$\nCode: class Solution { public: int closestValue(TreeNode* root, double target) { int cur = root-\u0026gt;val; TreeNode* branch = target \u0026lt; cur ? root-\u0026gt;left : root-\u0026gt;right; if (!branch) { return root-\u0026gt;val; } int r = closestValue(branch, target); return abs(r - target) \u0026lt; abs(cur - target) ? r : cur; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/reverse-vowels-of-a-string/",
	"title": "Reverse Vowels of a String",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Write a function that takes a string as input and reverse only the vowels of a string.\nExample 1:\nGiven s = \u0026ldquo;hello\u0026rdquo;, return \u0026ldquo;holle\u0026rdquo;.\nExample 2:\nGiven s = \u0026ldquo;leetcode\u0026rdquo;, return \u0026ldquo;leotcede\u0026rdquo;.\n Analysis: 跟reverse string一样,只不过需要找到vowel字母后再swap\nTime and space complexity: time: $\\Theta (n)$\nspace: $\\Theta (1)$\nCode: class Solution { public: string reverseVowels(string s) { int i = 0, j = (int)s.length() - 1; while (i \u0026lt; j) { while (i \u0026lt; (int)s.length() \u0026amp;\u0026amp; !isVowels(s[i])) { ++i; } if (i == (int)s.length()) { break; } while (j \u0026gt;= 0 \u0026amp;\u0026amp; !isVowels(s[j])) { --j; } if (j \u0026lt; 0) { break; } if (i \u0026lt; j) { swap(s[i++], s[j--]); } } return s; } bool isVowels(char \u0026amp;c) { switch (c) { case \u0026#39;a\u0026#39;: case \u0026#39;e\u0026#39;: case \u0026#39;i\u0026#39;: case \u0026#39;o\u0026#39;: case \u0026#39;u\u0026#39;: case \u0026#39;A\u0026#39;: case \u0026#39;E\u0026#39;: case \u0026#39;I\u0026#39;: case \u0026#39;O\u0026#39;: case \u0026#39;U\u0026#39;: return true; default: break; } return false; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/swap-nodes-in-pairs/",
	"title": "Swap Nodes in Pairs",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given a linked list, swap every two adjacent nodes and return its head.\nFor example, Given 1-\u0026gt;2-\u0026gt;3-\u0026gt;4, you should return the list as 2-\u0026gt;1-\u0026gt;4-\u0026gt;3.\nYour algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.\n Analysis: 利用二级指针,先swap node,然后更改指针指向的内存位置,跳到下一个位置继续\nTime and space complexity: time: $\\Theta (n)$\nspace: $\\Theta (1)$\nCode: class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode** pp = \u0026amp;head, *a, *b; while ((a = *pp) \u0026amp;\u0026amp; (b = a-\u0026gt;next)) { a-\u0026gt;next = b-\u0026gt;next; b-\u0026gt;next = a; *pp = b; pp = \u0026amp;(a-\u0026gt;next); } return head; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/merge-two-sorted-lists/",
	"title": "Merge Two Sorted Lists",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Merge Two Sorted Lists\n Analysis: 就是简单的merge\nTime and space complexity: time: $\\Theta (n)$\nspace: $\\Theta (1)$\nCode: class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode head(0); ListNode* pos = \u0026amp;head; while (l1 \u0026amp;\u0026amp; l2) { if (l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) { pos-\u0026gt;next = l1; l1 = l1-\u0026gt;next; } else { pos-\u0026gt;next = l2; l2 = l2-\u0026gt;next; } pos = pos-\u0026gt;next; } pos-\u0026gt;next = l1 ? l1 : l2; return head.next; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/best-time-to-buy-and-sell-stock/",
	"title": "Best Time to Buy and Sell Stock",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Say you have an array for which the ith element is the price of a given stock on day i.\nIf you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.\n Analysis: 遍历数组,记录到当前节点的最大值和最小值,当最小值变化后,同时更新最大值和最小值,因为前面的最大值和最小值在后面是用不到的\nTime and space complexity: time: $\\Theta (n)$\nspace: $\\Theta (1)$\nCode: class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { if (prices.empty()) { return 0; } int profit = 0; int low = prices.front(), high = prices.front(); for (auto p : prices) { if (low \u0026gt; p) { profit = max(profit, high - low); low = high = p; } high = max(high, p); } return max(profit, high - low); } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/strobogrammatic-number/",
	"title": "Strobogrammatic Number",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\nWrite a function to determine if a number is strobogrammatic. The number is represented as a string.\nFor example, the numbers \u0026ldquo;69\u0026rdquo;, \u0026ldquo;88\u0026rdquo;, and \u0026ldquo;818\u0026rdquo; are all strobogrammatic.\n Analysis: 和判断palindrome string一个思路,双指针\nTime and space complexity: time: $\\Theta (n)$\nspace: $\\Theta (1)$\nCode: class Solution { public: bool isStrobogrammatic(string num) { set\u0026lt;pair\u0026lt;char, char\u0026gt;\u0026gt; lookup; lookup.insert(make_pair(\u0026#39;1\u0026#39;, \u0026#39;1\u0026#39;)); lookup.insert(make_pair(\u0026#39;8\u0026#39;, \u0026#39;8\u0026#39;)); lookup.insert(make_pair(\u0026#39;6\u0026#39;, \u0026#39;9\u0026#39;)); lookup.insert(make_pair(\u0026#39;9\u0026#39;, \u0026#39;6\u0026#39;)); lookup.insert(make_pair(\u0026#39;0\u0026#39;, \u0026#39;0\u0026#39;)); for (int i = 0, j = num.size() - 1; i \u0026lt;= j; ++i, --j) { if (lookup.find(make_pair(num[i], num[j])) == lookup.end()) { return false; } } return true; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/ugly-number/",
	"title": "Ugly Number",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Write a program to check whether a given number is an ugly number.\nUgly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.\nNote that 1 is typically treated as an ugly number.\n Analysis: 对given number分别对2,3,5做module运算,如果有其中任何情况不为0,那么不是ugly number\nTime and space complexity: time: $\\Theta (a+b+c), number = 2^a3^b5^c$\nspace: $\\Theta (1) $\nCode: class Solution { public: bool isUgly(int num) { while (num) { if (num % 2 == 0) { num \u0026gt;\u0026gt;= 1; } else if (num % 3 == 0) { num /= 3; } else if (num % 5 == 0) { num /= 5; } else { break; } } return num == 1; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/happy-number/",
	"title": "Happy Number",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Write an algorithm to determine if a number is \u0026ldquo;happy\u0026rdquo;.\nA happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.\n Example: 19 is a happy number $1^2 + 9^2 = 82\n$ $8^2 + 2^2 = 68\n$ $6^2 + 8^2 = 100\n$ $1^2 + 0^2 + 0^2 = 1\n$\nAnalysis: 没有特别的方法,只能按照判断happy number的方法一直计算,如果是happy number,那么就最后会得到1,如果不是就会出现重复出现的数字\noptimize:\n根据Floyd Cycle detection,利用快慢的方法来检测是否出现重复的数字\nTime and space complexity time: $\\Theta $\nspace: $\\Theta (n) $,optimized $\\Theta (1) {% endmath %}\nCode class Solution { public: bool isHappy(int n) { std::unordered_set\u0026lt;uint64_t\u0026gt; record; while (n != 1) { if (record.find(n) != record.end()) { break; } record.insert(n); uint64_t tmp = 0; while (n) { tmp += std::pow(n % 10, 2); n /= 10; } n = tmp; } return n == 1; } }; optimized:\nint digitSquareSum(int n) { int sum = 0, tmp; while (n) { tmp = n % 10; sum += tmp * tmp; n /= 10; } return sum; } bool isHappy(int n) { int slow, fast; slow = fast = n; do { slow = digitSquareSum(slow); fast = digitSquareSum(fast); fast = digitSquareSum(fast); } while(slow != fast); if (slow == 1) return 1; else return 0; } "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/power-of-two/",
	"title": "Power of Two",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given an integer, write a function to determine if it is a power of two.\n Analysis: 快速的判断一个数是不是power of two, n \u0026amp; (n - 1) == 0\nexample:\n8 -\u0026gt; 1000 7 -\u0026gt; 0111 8 \u0026amp; 7 = 0 8是power of two\n或者数1的个数,只有1个1的数就是power of two\nTime and space complexity: time: $\\Theta (1) $\nspace:\nCode: class Solution { public: bool isPowerOfTwo(int n) { return n \u0026gt; 0 \u0026amp;\u0026amp; (n \u0026amp; (n - 1)) == 0; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/power-of-three/",
	"title": "Power of Three",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given an integer, write a function to determine if it is a power of three.\nFollow up:\nCould you do it without using any loop / recursion?\n Analysis: 不停的除以3直到数字变为1,并检查每次的结果module 3后是否为0\nfollow up: 用INT_MAX范围内最大的power of three来module被检查的数字,如果为0,则这个数字是power of three\nTime and space complexity: time: $\\Theta (n)$, n为$\\log_3 x{% endmath %}\nspace: $\\Theta (1)$\nCode: class Solution { public: bool isPowerOfThree(int n) { while (n \u0026gt; 0) { if (n % 3 == 0) { n /= 3; continue; } break; } return n == 1; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/climbing-stairs/",
	"title": "Climbing Stairs",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " You are climbing a stair case. It takes n steps to reach to the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n Analysis: DP的入门题\nformula: dp[i] = dp[i - 1] + dp[i - 2];\nTime and space complexity: time: $\\Theta (n)$\nspace: $\\Theta (1)$\nCode: class Solution { public: int climbStairs(int n) { int a = 1, b = 1; while (n--) { a = (b += a) - a; } return a; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/remove-duplicates-from-sorted-list/",
	"title": "Remove Duplicates from Sorted List",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given a sorted linked list, delete all duplicates such that each element appear only once.\nFor example, Given 1-\u0026gt;1-\u0026gt;2, return 1-\u0026gt;2. Given 1-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;3, return 1-\u0026gt;2-\u0026gt;3.\n Analysis: 和数组遍历去重复一样\nTime and space complexity: time: $\\Theta (n) $\nspace: $\\Theta (1) $\nCode: class Solution { public: ListNode* deleteDuplicates(ListNode* head) { ListNode* uniq = head; ListNode* cur; while (uniq) { cur = uniq; while (cur \u0026amp;\u0026amp; uniq-\u0026gt;val == cur-\u0026gt;val) { cur = cur-\u0026gt;next; } uniq-\u0026gt;next = cur; uniq = uniq-\u0026gt;next; } return head; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/linked-list-cycle/",
	"title": "Linked List Cycle",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given a linked list, determine if it has a cycle in it.\nFollow up: Can you solve it without using extra space?\n Analysis: native方式存储所有的node节点,如果查到相同的node节点表示有cycle.\nFollow up, 快慢指针追逐,一个指针每次走2步,一个指针每次走1步,如果快指针追上慢指针,说明有cycle,否则没有.快慢指针还有一个常用的功能就是找链表中点.\nTime and space complexity: time: $\\Theta (n)$\nspace: $\\Theta (1)$\nCode: class Solution { public: bool hasCycle(ListNode *head) { ListNode* slow = head, *fast = head; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; if (slow == fast) { return true; } } return false; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/number-of-1-bits/",
	"title": "Number of 1 Bits",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Write a function that takes an unsigned integer and returns the number of ’1\u0026rsquo; bits it has (also known as the Hamming weight).\nFor example, the 32-bit integer ’11\u0026rsquo; has binary representation 00000000000000000000000000001011, so the function should return 3.\n Analysis: 最native的方式就是不停的logical right shift,然后统计1的个数,循环次数最多为32次.更高级一点的办法是divide and conquer,先2个bit数1的个数然后再4个bit数1的个数,再8个bit数,直到数到32bit\nTime and space complexity: time: $\\Theta (1)$\nspace: $\\Theta (1)$\nCode: class Solution { public: int hammingWeight(uint32_t n) { n = (n \u0026amp; 0x55555555) + ((n \u0026gt;\u0026gt; 1) \u0026amp; 0x55555555); n = (n \u0026amp; 0x33333333) + ((n \u0026gt;\u0026gt; 2) \u0026amp; 0x33333333); n = (n \u0026amp; 0x0f0f0f0f) + ((n \u0026gt;\u0026gt; 4) \u0026amp; 0x0f0f0f0f); n = (n \u0026amp; 0x00ff00ff) + ((n \u0026gt;\u0026gt; 8) \u0026amp; 0x00ff00ff); n = (n \u0026amp; 0x0000ffff) + ((n \u0026gt;\u0026gt; 16) \u0026amp; 0x0000ffff); return n; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/lowest-common-ancestor-of-a-binary-search-tree/",
	"title": "Lowest Common Ancestor of a Binary Search Tree",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”\n  _______6______ / \\ ___2__ ___8__ / \\ / \\ 0 _4 7 9 / \\ 3 5  For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.\n Analysis: 根据binary search tree的特点,如果2个值都是小于根节点值,那么答案在左子树,如果都大于根节点那么答案在右子树,不然就是根节点\nTime and space complexity: time: $\\Theta(\\log(n)) $\nspace: $\\Theta (1)$\nCode: class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if (p -\u0026gt; val \u0026lt; root -\u0026gt; val \u0026amp;\u0026amp; q -\u0026gt; val \u0026lt; root -\u0026gt; val) return lowestCommonAncestor(root -\u0026gt; left, p, q); if (p -\u0026gt; val \u0026gt; root -\u0026gt; val \u0026amp;\u0026amp; q -\u0026gt; val \u0026gt; root -\u0026gt; val) return lowestCommonAncestor(root -\u0026gt; right, p, q); return root; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/roman-to-integer/",
	"title": "Roman to Integer",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given a roman numeral, convert it to an integer.\nInput is guaranteed to be within the range from 1 to 3999.\n Analysis: 从左往右依次读取,如果当前的字符代表的值大于后面的值,就把这个值+到最后的结果,不然就-,就像找递增数列一样\nTime and space complexity: time: $\\Theta (n)$\nspace: $\\Theta (1)$\nCode: class Solution { public: int romanToInt(string s) { std::map\u0026lt;char, int\u0026gt; lookup { {\u0026#39;I\u0026#39;, 1}, {\u0026#39;V\u0026#39;, 5}, {\u0026#39;X\u0026#39;, 10}, {\u0026#39;L\u0026#39;, 50}, {\u0026#39;C\u0026#39;, 100}, {\u0026#39;D\u0026#39;, 500}, {\u0026#39;M\u0026#39;, 1000}, }; int num = 0; int next = 0; for (int i = 0; i \u0026lt; (int) s.length(); i = next) { next = i + 1; while (next \u0026lt; (int) s.length() \u0026amp;\u0026amp; lookup[s[next]] \u0026gt; lookup[s[next - 1]]) { ++next; } num += lookup[s[next - 1]]; for (int j = i; j \u0026lt; next - 1; ++j) { num -= lookup[s[j]]; } } return num; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/reverse-linked-list/",
	"title": "Reverse Linked List",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Reverse a singly linked list.\n Analysis: 这个没有难度,不停的往头指针加入节点就可以\nTime and space complexity: time: $\\Theta (n)$\nspace: $\\Theta (1)$\nCode: class Solution { public: ListNode* reverseList(ListNode* head) { ListNode pivot(0); ListNode* pos = head; ListNode* next = nullptr; while (pos) { next = pos-\u0026gt;next; pos-\u0026gt;next = pivot.next; pivot.next = pos; pos = next; } return pivot.next; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/maximum-size-subarray-sum-equals-k/",
	"title": "Maximum Size Subarray Sum Equals k",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn\u0026rsquo;t one, return 0 instead.\nExample 1: Given nums = [1, -1, 5, -2, 3], k = 3, return 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longest)\nExample 2: Given nums = [-2, -1, 2, 1], k = 1, return 2. (because the subarray [-1, 2] sums to 1 and is the longest)\nFollow Up: Can you do it in $\\Theta (n)$ time?\n Analysis: 最native的方式就是O(n^2)了,从每个index开始,依次找满足target的subarry. Follow up, 用dp的方式记录从0到某一个位置的sum值和起始index,这样就能快速地求出从任意位置的长度任意subarray的sum值\nTime and space complexity: time: $\\Theta (n)$\nspace: $\\Theta (n)$\nCode: class Solution { public: int maxSubArrayLen(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { unordered_map\u0026lt;int, int\u0026gt; record; record[0] = -1; int size = nums.size(); int sum = 0; int len = 0; for (int i = 0; i \u0026lt; size; ++i) { sum += nums[i]; if (record.find(sum) == record.end()) { record[sum] = i; } if (record.find(sum - k) != record.end()) { len = max(len, i - record[sum - k]); } } return len; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/majority-element/",
	"title": "Majority Element",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.\nYou may assume that the array is non-empty and the majority element always exist in the array.\n Analysis: 最简单的方式是统计没有数字出现的次数,然后遍历一遍统计值,找出大于⌊ n/2 ⌋的那个数字. 还有一种更快速地方法Moore Voting,思路如下,用一个统计值表示当前的major出现的次数,然后遍历数组重复如下步骤:\n 如果统计值为0,更改major的值为当前值和统计值为1 如果统计值不为0,那么如果当前值和major的值不一致,统计值就-1,否则就+1 最后,major的值就为答案  Time and space complexity: time: $\\Theta (n)$\nspace: $\\Theta (1)$\nCode: class Solution { public: int majorityElement(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int major = nums[0]; int count = 1; for (int i = 1; i \u0026lt; (int) nums.size(); ++i) { if (!count) { count = 1; major = nums[i]; } else { count += (nums[i] == major) ? 1 : -1; } } return major; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/contains-duplicate/",
	"title": "Contains Duplicate",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.\n Analysis: 用unordered_set记录出现的数字,如果find到就返回true\nTime and space complexity: time: $\\Theta (n) $\nspace: $\\Theta (n) $\nCode: class Solution { public: bool containsDuplicate(vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::unordered_set\u0026lt;int\u0026gt; record; for (int\u0026amp; n : nums) { if (record.find(n) == record.end()) { record.insert(n); } else { return true; } } return false; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/meeting-rooms/",
	"title": "Meeting Rooms",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si \u0026lt; ei), determine if a person could attend all meetings.\nFor example, Given [[0, 30],[5, 10],[15, 20]], return false.\n Analysis: 简单地排序问题,将所有的interval按照开始时间排序, 然后遍历如果当前的interval的结束时间大于下一个interval的开始时间就返回false\nTime and space complexity: 排序时间为主要耗时 time: $\\Theta(n\\log n) $\nCode: class Solution { public: bool canAttendMeetings(vector\u0026lt;Interval\u0026gt;\u0026amp; intervals) { sort(intervals.begin(), intervals.end(), [](const Interval\u0026amp; a, const Interval\u0026amp; b){ return a.start \u0026lt; b.start; }); int size = intervals.size() - 1; for (int i = 0; i \u0026lt; size; ++i) { if (intervals[i].end \u0026gt; intervals[i + 1].start) { return false; } } return true; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/excel-sheet-column-number/",
	"title": "Excel Sheet Column Number",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Related to question Excel Sheet Column Title\nGiven a column title as appear in an Excel sheet, return its corresponding column number.\nFor example:\n  A -\u0026gt; 1 B -\u0026gt; 2 C -\u0026gt; 3 ... Z -\u0026gt; 26 AA -\u0026gt; 27 AB -\u0026gt; 28   Analysis: 类似于atoi,只不过不是10进制而是26进制\nTime and space complexity: time: $\\Theta (n)$\nCode: class Solution { public: int titleToNumber(string s) { int num = 0; for (char\u0026amp; c : s) { int n = c - \u0026#39;A\u0026#39; + 1; num = num * 26 + n; } return num; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/valid-anagram/",
	"title": "Valid Anagram",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given two strings s and t, write a function to determine if t is an anagram of s.\nFor example, s = \u0026quot;anagram\u0026quot;, t = \u0026quot;nagaram\u0026quot;, return true. s = \u0026quot;rat\u0026quot;, t = \u0026quot;car\u0026quot;, return false.\nNote: You may assume the string contains only lowercase alphabets.\nFollow up: What if the inputs contain unicode characters? How would you adapt your solution to such case?\n Analysis: 用统计字符来解决,follow up也可以用此方法解决\n 出现在s中的字符+1 出现在t中的字符-1 遍历一遍,统计的数字,如果某个字符的统计值不为0,就返回false  Time and space complexity: time: $\\Theta (n)$\nCode: class Solution { public: bool isAnagram(string s, string t) { std::vector\u0026lt;int\u0026gt; record(26, 0); for (char\u0026amp; c : s) { ++record[c - \u0026#39;a\u0026#39;]; } for (char\u0026amp; c : t) { --record[c - \u0026#39;a\u0026#39;]; } for (int\u0026amp; n : record) { if (n) { return false; } } return true; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/same-tree/",
	"title": "Same Tree",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given two binary trees, write a function to check if they are equal or not.\nTwo binary trees are considered equal if they are structurally identical and the nodes have the same value.\n Analysis: 对2棵树做DFS遍历,2个树为same tree的条件\n 当前2个节点都为空 当前2个节点都不为空,val相同  Time and space complexity: time: $\\Theta (n)$\nCode: class Solution { public: bool isSameTree(TreeNode* p, TreeNode* q) { if (!p \u0026amp;\u0026amp; !q) { return true; } if (p \u0026amp;\u0026amp; q \u0026amp;\u0026amp; p-\u0026gt;val == q-\u0026gt;val) { return isSameTree(p-\u0026gt;left, q-\u0026gt;left) \u0026amp;\u0026amp; isSameTree(p-\u0026gt;right, q-\u0026gt;right); } return false; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/delete-node-in-a-linked-list/",
	"title": "Delete Node in a Linked List",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.\nSupposed the linked list is 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 and you are given the third node with value 3, the linked list should become 1 -\u0026gt; 2 -\u0026gt; 4 after calling your function.\n Analysis: 将被删除元素的copy到这个元素中\nTime and space complexity: time: $\\Theta (1)$\nCode: class Solution { public: void deleteNode(ListNode* node) { *node = *node-\u0026gt;next; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/move-zeroes/",
	"title": "Move Zeroes",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.\nFor example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].\nNote:\n You must do this in-place without making a copy of the array. Minimize the total number of operations.   Analysis: 可以看做是排序的一种变形,in-place排序有冒泡,快排,题目要求最小的操作,冒泡显然不合适,所以用快排的partition函数\nTime and space complexity: time: $\\Theta (n)$\nCode: class Solution { public: void moveZeroes(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int last = 0, cur = 0; while (cur \u0026lt; (int)nums.size()) { if (nums[cur]) { swap(nums[last], nums[cur]) ++last; } ++cur; } } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/find-the-celebrity/",
	"title": "Find the Celebrity",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.\nNow you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: \u0026ldquo;Hi, A. Do you know B?\u0026rdquo; to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).\nYou are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n), your function should minimize the number of calls to knows.\nNote: There will be exactly one celebrity if he/she is in the party. Return the celebrity\u0026rsquo;s label if there is a celebrity in the party. If there is no celebrity, return -1.\n Analysis: Celebrity的定义是别人都认识他,他不认识所有人,根据这个定义我们可以知道如果一个人认识另外一个人,那么他肯定不是Celebrity,如果他不认识另外一个人,那么他可能是Celebrity.所以我们就先用一次遍历来找出可能的Celebrity,然后我们再遍历一次,验证这个人到底是不是Celebrity.\nTime and space complexity: time: $\\Theta (n) $\nCode: bool knows(int a, int b); class Solution { public: int findCelebrity(int n) { int candidate = 0; for (int i = 1; i \u0026lt; n; ++i) { if (knows(candidate, i)) { candidate = i; } } for (int i = 0; i \u0026lt; n; ++i) { if (i != candidate \u0026amp;\u0026amp; (knows(candidate, i) || !knows(i, candidate))) { return -1; } } return candidate; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/invert-binary-tree/",
	"title": "Invert Binary Tree",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Invert a binary tree.\n  4 / \\ 2 7 / \\ / \\ 1 3 6 9  to\n  4 / \\ 7 2 / \\ / \\ 9 6 3 1 Analysis: 后序遍历树,最后交换一下左子树和右子树\nTime and space complexity time: $\\Theta (n)$\nCode: class Solution { public: TreeNode* invertTree(TreeNode* root) { invert(root); return root; } private: void invert(TreeNode* node) { if (!node) { return; } invert(node-\u0026gt;left); invert(node-\u0026gt;right); std::swap(node-\u0026gt;left, node-\u0026gt;right); } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/shortest-word-distance/",
	"title": "Shortest Word Distance",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.\nFor example, Assume that words = [\u0026quot;practice\u0026quot;, \u0026quot;makes\u0026quot;, \u0026quot;perfect\u0026quot;, \u0026quot;coding\u0026quot;, \u0026quot;makes\u0026quot;].\nGiven word1 = “coding”, word2 = “practice”, return 3. Given word1 = \u0026quot;makes\u0026quot;, word2 = \u0026quot;coding\u0026quot;, return 1.\nNote: You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.\n Analysis: 遍历一遍所有的words,记录word1和word2出现的位置,最后求一下位置的差值的绝对值\nTime and space complexity: time: $\\Theta (n)$ space: $\\Theta (1)$\nCode: class Solution { public: int shortestDistance(vector\u0026lt;string\u0026gt;\u0026amp; words, string word1, string word2) { int distance = words.size(); int p1 = -1, p2 = -1; int pos = 0; for (string\u0026amp; s : words) { if (s == word1) { p1 = pos; } else if (s == word2) { p2 = pos; } if (p1 != -1 \u0026amp;\u0026amp; p2 != -1) { distance = min(distance, abs(p1 - p2)); } ++pos; } return distance; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/maximum-depth-of-binary-tree/",
	"title": "Maximum Depth of Binary Tree",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given a binary tree, find its maximum depth.\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n Analysis: DFS遍历一遍树,保存最大的depth\nTime and space complexity time: $\\Theta (n)$\nCode: class Solution { public: int maxDepth(TreeNode* root) { int depth = 0; recordDepth(root, 0, depth); return depth; } private: void recordDepth(TreeNode* node, int curDepth, int\u0026amp; maxDepth) { if (!node) { maxDepth = std::max(curDepth, maxDepth); return; } recordDepth(node-\u0026gt;left, curDepth + 1, maxDepth); recordDepth(node-\u0026gt;right, curDepth + 1, maxDepth); } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/add-digits/",
	"title": "Add Digits",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\nGiven num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.\nFollow up: Could you do it without any loop/recursion in $\\Theta (1) $ runtime?\n Analysis: 最简单的方法就是按照例子给出的一样对每个数字做加法,然后不停迭代直到最后的num \u0026lt; 10\nFollow up:\n通过观察可以发现如下规律:\n0 % 9 = 0 # 0 1 % 9 = 1 # 1 ... 9 % 9 = 0 # 9 10 % 9 = 1 # 1 + 0 = 1 11 % 9 = 2 # 1 + 1 = 2 所以解决方式就是简单的对num对9取modulo,对0这个数字需要特殊处理一下就可以\nTime and space complexity time: $\\Theta (1)$\nCode: class Solution { public: int addDigits(int num) { int mod = num % 9; return num == 0 ? 0 : (mod == 0 ? 9 : mod); } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/flip-game/",
	"title": "Flip Game",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two consecutive \u0026quot;++\u0026quot; into \u0026quot;--\u0026quot;. The game ends when a person can no longer make a move and therefore the other person will be the winner.\nWrite a function to compute all possible states of the string after one valid move.\nFor example, given s = \u0026quot;++++\u0026quot;, after one move, it may become one of the following states:\n [ \u0026#34;--++\u0026#34;, \u0026#34;+--+\u0026#34;, \u0026#34;++--\u0026#34; ]  If there is no valid move, return an empty list [].\n Analysis: 这个就是简单的寻找连续2个++字符,找到后变成--\nTime and space complexity time: $\\Theta (n) $\nCode: class Solution { public: vector\u0026lt;string\u0026gt; generatePossibleNextMoves(string s) { vector\u0026lt;string\u0026gt; result; int size = s.size() - 1; for (int i = 0; i \u0026lt; size; ++i) { if (s[i] == \u0026#39;+\u0026#39; \u0026amp;\u0026amp; s[i] == s[i + 1]) { string valid(s); valid[i] = \u0026#39;-\u0026#39;; valid[i + 1] = \u0026#39;-\u0026#39;; result.push_back(valid); } } return result; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/palindrome-permutation/",
	"title": "Palindrome Permutation",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given a string, determine if a permutation of the string could form a palindrome.\nFor example,\n\u0026quot;code\u0026quot; -\u0026gt; false, \u0026quot;aab\u0026quot; -\u0026gt; true, \u0026quot;carerac\u0026quot; -\u0026gt; true.\n Analysis: 这个问题可以看做是简单的统计字符问题,如果字符串每个字符都是偶数个,或者只有一个字符的数量是奇数个,那么这个字符串就会是palindrome permutation\nTime and space complexity time: $\\Theta (n)$\nspace: $\\Theta (n)$\nCode: class Solution { public: bool canPermutePalindrome(string s) { unordered_map\u0026lt;char, int\u0026gt; count; for (char\u0026amp; c : s) { ++count[c]; } int odd = 0; for (auto it = count.begin(); it != count.end(); ++it) { if (it-\u0026gt;second % 2 == 0) { continue; } ++odd; } return odd \u0026lt;= 1; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/nim-game/",
	"title": "Nim Game",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.\nBoth of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.\nFor example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.\n Analysis: 这个问题其实可以简单的看做一个整除问题,如果总共的石头是4x个,也就是4的倍数,每当你拿x个石头,你的对手只要4-x个石头,这样无论如何你都不会赢,其他的情况是则是可能赢\nTime and space complexity time: $\\Theta (1)$\nCode: class Solution { public: bool canWinNim(int n) { return !(n % 4 == 0); } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/nested-list-weight-sum/",
	"title": "Nested List Weight Sum",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Given a nested list of integers, return the sum of all integers in the list weighted by their depth.\nEach element is either an integer, or a list \u0026ndash; whose elements may also be integers or other lists.\nExample 1:\nGiven the list [[1,1],2,[1,1]], return 10. (four 1\u0026rsquo;s at depth 2, one 2 at depth 1)\nExample 2:\nGiven the list [1,[4,[6]]], return 27. (one 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 42 + 63 = 27)\n Analysis: 首先NestedInteger类提供了一下3个接口\n// Return true if this NestedInteger holds a single integer, rather than a nested list. bool isInteger() const; // Return the single integer that this NestedInteger holds, if it holds a single integer // The result is undefined if this NestedInteger holds a nested list int getInteger() const; // Return the nested list that this NestedInteger holds, if it holds a nested list  // The result is undefined if this NestedInteger holds a single integer  const vector\u0026lt;NestedInteger\u0026gt; \u0026amp;getList() const; 根据这3个接口,我们的解决方案思路大概就是这样的:\n isInteger先判断一下是不是只有一个数字 如果是那么直接用getInteger获得的值与当前的depth值相乘并记录 不是数字调用getList(),然后递归调用depthSum  Time and space complexity time: $\\Theta (n)$\nCode: class Solution { public: int depthSum(vector\u0026lt;NestedInteger\u0026gt;\u0026amp; nestedList) { return helper(nestedList, 1); } int helper(vector\u0026lt;NestedInteger\u0026gt;\u0026amp; list, int depth) { int sum = 0; for (auto i : list) { if (i.isInteger()) { sum += depth * i.getInteger(); } else { sum += helper(i.getList(), depth + 1); } } return sum; } }; "
},
{
	"uri": "http://mymneo.github.io/posts/algorithm/reverse-string/",
	"title": "Reverse String",
	"tags": ["leetcode", "algorithm"],
	"description": "",
	"content": " Write a function that takes a string as input and returns the string reversed.\nExample:\nGiven s = \u0026ldquo;hello\u0026rdquo;, return \u0026ldquo;olleh\u0026rdquo;.\n Analysis: 用头尾2个指针进行遍历,遍历的同时进行交换\nTime ans space complexity time: $\\Theta (n) $\nCode: class Solution { public: string reverseString(string s) { int i = 0, j = (int)s.length() - 1; while (i \u0026lt; j) { swap(s[i++], s[j--]); } return s; } }; "
},
{
	"uri": "http://mymneo.github.io/tags/mac/",
	"title": "mac",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/posts/mac-cheatsheet/",
	"title": "mac cheatsheet",
	"tags": ["mac", "cheatsheet"],
	"description": "",
	"content": " Reset Launchpad Layout in OS X El Capitan \u0026amp; Yosemite  defaults write com.apple.dock ResetLaunchPad -bool true; killall Dock "
},
{
	"uri": "http://mymneo.github.io/tags/golang/",
	"title": "golang",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/posts/golang-functions/",
	"title": "golang memo",
	"tags": ["programme", "golang"],
	"description": "",
	"content": " tell you file and line number like C  runtime.Caller(0)  iterate over some field in structure  package main import \u0026#34;fmt\u0026#34; import \u0026#34;reflect\u0026#34; import \u0026#34;strings\u0026#34; type MyStruct struct { A,B,C string I int D string J int } func main() { ms := MyStruct{\u0026#34;Green \u0026#34;, \u0026#34; Eggs\u0026#34;, \u0026#34; and \u0026#34;, 2, \u0026#34; Ham \u0026#34;, 15} // Print it out now so we can see the difference  fmt.Printf(\u0026#34;%s%s%s%d%s%d\\n\u0026#34;, ms.A, ms.B, ms.C, ms.I, ms.D, ms.J) // We need a pointer so that we can set the value via reflection  msValuePtr := reflect.ValueOf(\u0026amp;ms) msValue := msValuePtr.Elem() for i := 0; i \u0026lt; msValue.NumField(); i++ { field := msValue.Field(i) // Ignore fields that don\u0026#39;t have the same type as a string  if field.Type() != reflect.TypeOf(\u0026#34;\u0026#34;) { continue } str := field.Interface().(string) str = strings.TrimSpace(str) field.SetString(str) } fmt.Printf(\u0026#34;%s%s%s%d%s%d\\n\u0026#34;, ms.A, ms.B, ms.C, ms.I, ms.D, ms.J) }  underscore usage   used in import   invoke the init function but not import other function of this package  import _ \u0026#34;net/http/pprof\u0026#34;  user in returned value   ignore the some value  for _, v := range Slice{}  used in variable   type assertion  type T struct{} var _ I = T{} # judge whether type T has implements I interface, if not, raise an error while compiling  cgo   Refer to a C struct field named type   Within the Go file, C identifiers or field names that are keywords in Go can be accessed by prefixing them with an underscore: if x points at a C struct with a field named \u0026ldquo;type\u0026rdquo;, x._type accesses the field\n export go function to c library  //export \u0026lt;function\u0026gt;  Notice, you can\u0026rsquo;t add space between // and export, but you can add space when import c header file or add #cgo\n when convert Go string to char* or Go []byte slice to C array, don\u0026rsquo;t forget free the memory, other transformation doesn\u0026rsquo;t has to do so  cstr := C.CString(\u0026#34;hello\u0026#34;) C.free(unsafe.Pointer(cstr)) cbytes := C.CBytes([]byte) C.free(cbytes) // C string to Go string func C.GoString(*C.char) string // C data with explicit length to Go string func C.GoStringN(*C.char, C.int) string // C data with explicit length to Go []byte func C.GoBytes(unsafe.Pointer, C.int) []byte basic type of C in different package is not the same type, that means  package pkg1 func test(arg C.char) {} package pkg2 func test(arg C.char) {} the type of arg is not the same\n goroutine  goroutine use a small stack to save variables and current procedure. It will generate a new thread if current goroutine is blocked by some reason such as Open or Write (https://groups.google.com/forum/#!topic/golang-nuts/2IdA34yR8gQ)\nIf you change the namespace(network etc) in goroutine by setns, the current thread\u0026rsquo;s namespace is changed, next time a new goroutine maybe execute it code in this thread, but it does not work well because the thread\u0026rsquo;s namespace has been changed. And also if you change environment in goroutine. It will affect the whole process environment.\nHere is an example:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; \u0026#34;syscall\u0026#34; \u0026#34;time\u0026#34; ) var ( forked = false ) func init() { if len(os.Args) \u0026gt; 1 { forked = true } } func main() { if forked { forklnk, _ := os.Readlink(fmt.Sprintf(\u0026#34;/proc/%d/task/%d/ns/net\u0026#34;, os.Getpid(), syscall.Gettid())) fmt.Printf(\u0026#34;forked network namespace: %s\\n\u0026#34;, forklnk) os.Exit(0) } origin, _ := os.Readlink(fmt.Sprintf(\u0026#34;/proc/%d/task/%d/ns/net\u0026#34;, os.Getpid(), syscall.Gettid())) fmt.Printf(\u0026#34;origin network namespace: %s\\n\u0026#34;, origin) r, w, err := os.Pipe() if err != nil { fmt.Printf(\u0026#34;pipe: %+v\\n\u0026#34;, err) } start := make(chan int, 1) go func() { start \u0026lt;- 1 f, _ := syscall.Open(\u0026#34;/proc/1/ns/net\u0026#34;, syscall.O_RDONLY, 0) init, _ := os.Readlink(\u0026#34;/proc/1/ns/net\u0026#34;) fmt.Printf(\u0026#34;init network namespace: %s\\n\u0026#34;, init) os.Setenv(\u0026#34;HELLO\u0026#34;, \u0026#34;k\u0026#34;) syscall.Syscall(308, uintptr(f), uintptr(0x40000000), 0) cmd := exec.Command(\u0026#34;/proc/self/exe\u0026#34;, \u0026#34;fork\u0026#34;) cmd.Stdout = w cmd.Run() cmd.Wait() r.Close() w.Close() }() afterlnk, _ := os.Readlink(fmt.Sprintf(\u0026#34;/proc/%d/task/%d/ns/net\u0026#34;, os.Getpid(), syscall.Gettid())) fmt.Printf(\u0026#34;after network namespace: %s\\n\u0026#34;, afterlnk) \u0026lt;-start for { _, err := io.Copy(os.Stdout, r) if err != nil { break } } if len(os.Getenv(\u0026#34;HELLO\u0026#34;)) \u0026gt; 0 { fmt.Printf(\u0026#34;outer env: %s\\n\u0026#34;, os.Getenv(\u0026#34;HELLO\u0026#34;)) } for { go func() { if len(os.Getenv(\u0026#34;HELLO\u0026#34;)) \u0026gt; 0 { fmt.Printf(\u0026#34;inter env: %s\\n\u0026#34;, os.Getenv(\u0026#34;HELLO\u0026#34;)) } inner, _ := os.Readlink(fmt.Sprintf(\u0026#34;/proc/%d/task/%d/ns/net\u0026#34;, os.Getpid(), syscall.Gettid())) fmt.Printf(\u0026#34;inner network namespace: %s\\n\u0026#34;, inner) }() time.Sleep(time.Second) } } Outputs:\n# go build test.go \u0026amp;\u0026amp; unshare -n ./test origin network namespace: net:[4026532300] after network namespace: net:[4026532300] init network namespace: net:[4026531969] forked network namespace: net:[4026531969] outer env: k inter env: k \u0026lt;- environment changed inner network namespace: net:[4026532300] \u0026lt;- origin namespace inter env: k inner network namespace: net:[4026531969] inter env: k inner network namespace: net:[4026531969] \u0026lt;- change namspace inter env: k inner network namespace: net:[4026531969] inter env: k inner network namespace: net:[4026531969] To avoid this situation happened, you must be careful about your code. DO NOT CHANGE THE CONTEXT IN GOROUTINES\n golang bit operation   revert bits  a := ^a // ~a in C change sign  a := ^a + 1 // ~a + 1 in C shift  a := a \u0026lt;\u0026lt; 1 // a \u0026lt;\u0026lt; 1 in C a := a \u0026gt;\u0026gt; 1 // a \u0026gt;\u0026gt; 1 in C  resolve error: \u0026ldquo;no buildable Go source files in\u0026rdquo;  Check if the package which shows error “no buildable Go source files in” is using C code, like\nimport \u0026#34;C\u0026#34; in the source file, in that case, we might see an error, when we try to compile as “go build”, most probably when we try to cross compile that code,\nThe solution is to add “CGO_ENABLED=1” while building the code,\nCGO_ENABLED=1 go build  Use the reflect package to get the string keys from a map with arbitrary value type  func Keys(v interface{}) ([]string, error) { rv := reflect.ValueOf(v) if rv.Kind() != reflect.Map { return nil, errors.New(\u0026#34;not a map\u0026#34;) } t := rv.Type() if t.Key().Kind() != reflect.String { return nil, errors.New(\u0026#34;not string key\u0026#34;) } var result []string for _, kv := range rv.MapKeys() { result = append(result, kv.String()) } return result, nil }  Custom Tag  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) // Name of the struct tag used in examples const tagName = \u0026#34;validate\u0026#34; type User struct { Id int `validate:\u0026#34;-\u0026#34;` Name string `validate:\u0026#34;presence,min=2,max=32\u0026#34;` Email string `validate:\u0026#34;email,required\u0026#34;` } func main() { user := User{ Id: 1, Name: \u0026#34;John Doe\u0026#34;, Email: \u0026#34;john@example\u0026#34;, } // TypeOf returns the reflection Type that represents the dynamic type of variable.  // If variable is a nil interface value, TypeOf returns nil.  t := reflect.TypeOf(user) // Get the type and kind of our user variable  fmt.Println(\u0026#34;Type:\u0026#34;, t.Name()) fmt.Println(\u0026#34;Kind:\u0026#34;, t.Kind()) // Iterate over all available fields and read the tag value  for i := 0; i \u0026lt; t.NumField(); i++ { // Get the field, returns https://golang.org/pkg/reflect/#StructField  field := t.Field(i) // Get the field tag value  tag := field.Tag.Get(tagName) fmt.Printf(\u0026#34;%d. %v (%v), tag: \u0026#39;%v\u0026#39;\\n\u0026#34;, i+1, field.Name, field.Type.Name(), tag) } }  Iterate slice  package main import \u0026#34;fmt\u0026#34; import \u0026#34;reflect\u0026#34; func main() { data := []string{\u0026#34;one\u0026#34;,\u0026#34;two\u0026#34;,\u0026#34;three\u0026#34;} test(data) moredata := []int{1,2,3} test(moredata) } func test(t interface{}) { switch reflect.TypeOf(t).Kind() { case reflect.Slice: s := reflect.ValueOf(t) for i := 0; i \u0026lt; s.Len(); i++ { fmt.Println(s.Index(i)) } } }  Get the Field of the Type Definition not of the Value  package main import \u0026#34;fmt\u0026#34; import \u0026#34;reflect\u0026#34; type A struct { Foo string } func (a *A) PrintFoo(){ fmt.Println(\u0026#34;Foo value is \u0026#34; + a.Foo) } func main() { a := \u0026amp;A{Foo: \u0026#34;afoo\u0026#34;} val := reflect.Indirect(reflect.ValueOf(a)) fmt.Println(val.Type().Field(0).Name) } "
},
{
	"uri": "http://mymneo.github.io/tags/programme/",
	"title": "programme",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/posts/git-command/",
	"title": "git command",
	"tags": ["git"],
	"description": "",
	"content": " branch  git checkout -b \u0026lt;branch name\u0026gt; # checkout with \u0026lt;branch name\u0026gt; git push origin \u0026lt;branch name\u0026gt; # push changes to remote named \u0026#39;origin\u0026#39; with \u0026lt;branch name\u0026gt; git push origin :\u0026lt;branch name\u0026gt; # delete remote named \u0026#39;origin\u0026#39; \u0026lt;branch name\u0026gt;  commit  git rebase -i \u0026lt;commit lists\u0026gt; # rebase \u0026lt;commit lists\u0026gt; with interactive mode, it can re-order commits git reset --hard \u0026lt;commit id\u0026gt; # Resets the index and working tree. Any changes to tracked files in the working tree since \u0026lt;commit\u0026gt; are discarded. git reset --mixed \u0026lt;commit id\u0026gt; # Resets the index but not the working tree (i.e., the changed files are preserved but not marked for commit) and reports what has not been updated. This is the default action. git show \u0026lt;commit id\u0026gt; # show \u0026lt;commit id\u0026gt; content  patch  git format-patch -1 \u0026lt;commit id\u0026gt; # generate patch related to \u0026lt;commit id\u0026gt; git format-path HEAD~n # generate last n commits patches git am \u0026lt;patch name\u0026gt; # apply \u0026lt;patch name\u0026gt; git apply --reject \u0026lt;patch name\u0026gt; # apply the files without conflicts in patch, leave conflict files with tags  repository  git fetch \u0026lt;repository\u0026gt; git checkout master git rebase \u0026lt;repository\u0026gt;/master git push -f origin master # all the above are used to update a forked repository  history  git log -p \u0026lt;filename\u0026gt; # view the change history of \u0026lt;filename\u0026gt;  archive  git archive \u0026lt;branch name\u0026gt; --prefix=\u0026lt;prefix\u0026gt; --format=\u0026lt;zip,tar\u0026gt; -o \u0026lt;filename\u0026gt;  recover delete commit  back up your entire directory, including the .git directory. You can use git fsck --lost-found to obtain the ID of the lost commits. rebase or merge onto the lost commit.   get current branch name  git rev-parse --abbrev-ref HEAD  clean remote branch  git remote prune \u0026lt;remote repository\u0026gt; "
},
{
	"uri": "http://mymneo.github.io/tags/makefile/",
	"title": "makefile",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/posts/makefile-memo/",
	"title": "makefile memo",
	"tags": ["linux", "makefile"],
	"description": "",
	"content": " Checks if the first argument is non-empty.If so runs the second argument, otherwise runs the third  $(if this-is-not-empty,then!,else!)  Execute command but not display on standard output  @ls .  tell make to ignore error  -rm -f *.*  The foreach function is very different from other functions. It causes one piece of text to be used repeatedly, each time with a different substitution performed on it. It resembles the for command in the shell sh and the foreach command in the C-shell csh.  $(foreach var,list,text) "
},
{
	"uri": "http://mymneo.github.io/tags/rpm/",
	"title": "rpm",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/tags/rpmbuild/",
	"title": "rpmbuild",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/posts/rpmbuild-tutorial/",
	"title": "rpmbuild easy tutorial",
	"tags": ["linux", "rpmbuild"],
	"description": "",
	"content": " 创建好文件夹结构  SOURCES 包含源代码,补丁,图标文件等 SPECS 包含spec文件,这些文件用来控制构建过程 BUILD 用来解压源代码的目录和软件构建的目录 RPMS 包含构建程序最后产生的RPM包 SPRMS 包含构建程序最后产生的源代码包文件   放置源代码到SOURCES文件夹中 编写spec文件   常用label     label description     Name 表明这个包叫什么名字，通常来说，一般用软件的名字作为name，name存在于最后的包的标签和包的文件名字中   Version 表示这个软件被打包后的版本，版本存在于最后包的标签和包的名字   Release 表示这个软件的时间信息，表示何时什么版本的软件被打包，你可以当作这个是包的版本号，这个信息最后作为最后包的标签和文件名的一部分   Group 用来存储这个被打包的文件与其他包的组关系，这段信息由很多词构成，以/分割。从左到右描述的更为精确   Source 说明被打包的软件的源代码在哪里可以被发现;告诉存在SOURCES文件夹中的源文件的名字   URL 通常含有一个URL，像Source那行，与source的区别是，source通常给RPM提供源代码的名字，URL是用来指明被打包的软件是文档信息   Distribution 告知被打包的软件是属于那个产品的   Vendor 指明那个组织发布的这个软件   Packager 指明组织中那个作者打包的这个软件   License 许可证   Requires 说明这个包需要的依赖条件   BuildRoot 说明这个包构建的根目录     常用section     section description     description 更详细的描述包的内容   define 定义自己的macro   prep 创建软件的构建环境，可以执行多条shell命令   build 执行build的多条命令   install 执行install的多条命令   files 列出来的文件都会被打进RPM包中   defattr RPM安装的文件默认的权限，拥有者和组   pre 在安装前执行的命令   post 在安装后执行的命令   preun 在卸载前执行的命令   postun 在卸载后执行的命令   package 生成子包    创建Subpackages   简单的来说,subpackage是同一个spec文件创建出来众多package中的一个,RPM可以创建一个主要的package同时创建一个或者多个subpackage,subpackges可以不从主要的package中产生,这些都是根据package builder的规则来确定\n  Example: {% codeblock lang:spec example.spec %} Name: foo Version: 2.7 Release: 1 Source: foo-2.7.tgz CopyRight: probably not Summary: The foo app, and the baz library needed to build it Group: bogus/junque %description This is the long description of the foo app, and the baz library needed to build it\u0026hellip;\n%packge server will result in the name of the subpackage being foo-server %package server Summary: The foo server Group: bogus/junque %description server This is the long description for the foo server\u0026hellip;\n%package client Summary: The foo client Group: bogus/junque %description client This is the long description for the foo client\u0026hellip;\nThe -n option is used to change the final name of a subpackage from -to . %package -n bazlib Version: 5.6 Summary: The baz library Group: bogus/junque %description -n bazlib This is the long description for the bazlib\u0026hellip;\n%pre echo \u0026ldquo;This is the foo package preinstall script\u0026rdquo;\n%pre server echo \u0026ldquo;This is the foo-server subpackage preinstall script\u0026rdquo;\n%pre client echo \u0026ldquo;This is the foo-client subpackage preinstall script\u0026rdquo;\n%pre -n bazlib echo \u0026ldquo;This is the bazlib subpackage preinstall script\u0026rdquo;\n%files /usr/local/foo-file\n%files server /usr/local/server-file\n%files client /usr/local/client-file\n%files -n bazlib /usr/local/bazlib-file {% endcodeblock %}\n"
},
{
	"uri": "http://mymneo.github.io/posts/rpm-and-yum-cheatsheet/",
	"title": "rpm and yum cheatsheet",
	"tags": ["linux", "rpm"],
	"description": "",
	"content": " query the dependency of a package  rpm -qR \u0026lt;package-name\u0026gt;  query the dependency of a rpm file  rpm -qpR \u0026lt;rpm-file\u0026gt;  query which rpm this file belongs to  rpm -qif \u0026lt;filename\u0026gt;  query non-installed rpm file  rpm -qip \u0026lt;rpm-file\u0026gt;  setup yum with proxy  append proxy=\u0026lt;your proxy\u0026gt; to /etc/yum.conf\n[main] proxy=\u0026lt;your proxy\u0026gt; if you don\u0026rsquo;t want proxy in some repository\nappend proxy=_none_ to your repo file\n"
},
{
	"uri": "http://mymneo.github.io/posts/sed-command/",
	"title": "Frequent commands about linux sed",
	"tags": ["linux", "sed"],
	"description": "",
	"content": " add content at last line  sed \u0026#39;$a\u0026lt;content\u0026gt;\u0026#39; \u0026lt;file\u0026gt;  add content at line  sed \u0026#39;\u0026lt;line\u0026gt;i\u0026lt;content\u0026gt;\u0026#39; \u0026lt;file\u0026gt;  delete line  sed \u0026#39;\u0026lt;line\u0026gt;d\u0026#39; \u0026lt;file\u0026gt;  match pattern, then execute expression  sed \u0026#39;/\u0026lt;regex\u0026gt;/\u0026lt;command\u0026gt;\u0026#39; \u0026lt;file\u0026gt;  print line number of matched pattern  sed \u0026#39;/\u0026lt;regex\u0026gt;/{=}\u0026#39; \u0026lt;file\u0026gt; Zero- or One- address commands in linux sed : # label = # line_number a # append_text_to_stdout_after_flush b # branch_unconditional c # range_change d # pattern_delete_top/cycle D # pattern_ltrunc(line+nl)_top/cycle g # pattern=hold G # pattern+=nl+hold h # hold=pattern H # hold+=nl+pattern i # insert_text_to_stdout_now l # pattern_list n # pattern_flush=nextline_continue N # pattern+=nl+nextline p # pattern_print P # pattern_first_line_print q # flush_quit r # append_file_to_stdout_after_flush s # substitute t # branch_on_substitute w # append_pattern_to_file_now x # swap_pattern_and_hold y # transform_chars "
},
{
	"uri": "http://mymneo.github.io/tags/sed/",
	"title": "sed",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/posts/docker-registry/",
	"title": "docker registry",
	"tags": ["docker"],
	"description": "",
	"content": " search v1 repository list  curl http://registry.com/v1/search  pull image  docker pull \u0026lt;hub address\u0026gt;/\u0026lt;name\u0026gt;  push image  docker tag \u0026lt;image id or image name\u0026gt; \u0026lt;hub address\u0026gt;/\u0026lt;name\u0026gt;:\u0026lt;version\u0026gt; docker push \u0026lt;hub address\u0026gt;/\u0026lt;name\u0026gt;:\u0026lt;version\u0026gt;  save image  docker save -o \u0026lt;filename\u0026gt; \u0026lt;image id or image name\u0026gt;  load image  docker load -i \u0026lt;filename\u0026gt; "
},
{
	"uri": "http://mymneo.github.io/tags/iptables/",
	"title": "iptables",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/posts/iptables/",
	"title": "iptables command(docker related)",
	"tags": ["linux", "iptables", "docker"],
	"description": "",
	"content": " flush all rules  sudo iptables -P INPUT ACCEPT sudo iptables -P FORWARD ACCEPT sudo iptables -P OUTPUT ACCEPT sudo iptables -F sudo iptables -X sudo iptables -t nat -F sudo iptables -t nat -X "
},
{
	"uri": "http://mymneo.github.io/tags/hadoop/",
	"title": "hadoop",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/tags/log4j/",
	"title": "log4j",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mymneo.github.io/posts/log4j-configuration/",
	"title": "log4j configuration",
	"tags": ["log4j", "hadoop"],
	"description": "",
	"content": "开始学习Hadoop的时候看代码是很枯燥的,就算看懂了对整个系统的流程可能还是不是很了解,这时候从日志文件着手就能快速地了解一个系统是大致流程,Hadoop使用的是log4j这个日志系统,默认的情况下Hadoop不会给每个类记录日志,需要手动的配置.\n如果需要配置某一个类的日志输出需要如下的填写方式:\nlog4j.logger.类名=日志级别, 自定义名称 log4j.appender.自定义名称\n例如:\n 配置org.apache.hadoop.yarn.server.nodemanager.containermanager.ContainerManagerImpl类 日志级别为Info 日志名称为ContainerManagerImpl日志使用按天滚动添加 日志文件的日期格式为xxx-dd.log 日志存放位置为${hadoop.log.dir}/ContainerManagerImpl.log  {% codeblock log4j.property lang:xml %} log4j.logger.org.apache.hadoop.yarn.server.nodemanager.containermanager.ContainerManagerImpl=INFO, ContainerManagerImpl log4j.appender.ContainerManagerImpl=org.apache.log4j.DailyRollingFileAppender log4j.appender.ContainerManagerImpl.datePattern=\u0026rsquo;-\u0026lsquo;dd\u0026rsquo;.log\u0026rsquo; log4j.appender.ContainerManagerImpl.File=${hadoop.log.dir}/ContainerManagerImpl.log log4j.appender.ContainerManagerImpl.layout=org.apache.log4j.PatternLayout log4j.appender.ContainerManagerImpl.layout.ConversionPattern=%-6r %d{ISO8601} %-5p %40.40c %x - %m%n {% endcodeblock %}\n"
},
{
	"uri": "http://mymneo.github.io/posts/vim-plugins/",
	"title": "vim plugins",
	"tags": ["vim", "production"],
	"description": "",
	"content": "工欲善其事,必先利其器.对于天天在类Unix写后台的代码的人来说,便捷的插件会使你写代码的速度加快很多.下面介绍一下我经常使用的插件(直接粘贴的英文,英文不好):\n   插件名称 简介     Vundle 统一管理所有vim插件的工具,让你管理插件very easy   google/vim-maktaba Maktaba is a vimscript plugin library. It is designed for plugin authors   google/vim-codefmt codefmt is a utility for syntax-aware code formatting. It contains several built-in formatters, and allows new formatters to be registered by other plugins.   google/vim-glaive Glaive is a utility for configuring maktaba plugins.   tpope/vim-fugitive I\u0026rsquo;m not going to lie to you; fugitive.vim may very well be the best Git wrapper of all time.   vim-scripts/LargeFile Editing large files can be a time consuming process as Vim is working on a number of things behind the scenes, such as maintaining an undo database, searching for a syntax highlighting synchronization point, etc. LargeFile.vim is a very small \u0026ldquo;plugin\u0026rdquo;; mostly, its just an autocmd that disables certain features of vim in the interests of speed.   scrooloose/nerdcommenter Vim plugin for intensely orgasmic commenting   Lokaltog/vim-easymotion Vim motions on speed!   Raimondi/delimitMate This plug-in provides automatic closing of quotes, parenthesis, brackets, etc., besides some other related features that should make your time in insert mode a little bit easier, like syntax awareness (will not insert the closing delimiter in comments and other configurable regions), and expansions (off by default), and some more.   mbbill/fencview Auto detect CJK and Unicode file encodings.   vim-scripts/Visual-Mark Visual mark, similar to UltraEdit\u0026rsquo;s bookmark   Valloric/YouCompleteMe A code-completion engine for Vim   google/vim-searchindex This plugin shows how many times does a search pattern occur in the current buffer. After each search, it displays total number of matches, as well as the index of a current match, in the command line   fatih/vim-go Go (golang) support for Vim, which comes with pre-defined sensible settings (like auto gofmt on save), with autocomplete, snippet support, improved syntax highlighting, go toolchain commands, and more. If needed vim-go installs all necessary binaries for providing seamless Vim integration with current commands. It\u0026rsquo;s highly customizable and each individual feature can be disabled/enabled easily.   scrooloose/nerdtree The NERD tree allows you to explore your filesystem and to open files and directories. It presents the filesystem to you in the form of a tree which you manipulate with the keyboard and/or mouse. It also allows you to perform simple filesystem operations.   Xuyuanp/nerdtree-git-plugin A plugin of NERDTree showing git status flags. Works with the LATEST version of NERDTree.   google/vim-colorscheme-primary google Vim colors scheme   airblade/vim-gitgutter A Vim plugin which shows a git diff in the \u0026lsquo;gutter\u0026rsquo; (sign column). It shows whether each line has been added, modified, and where lines have been removed. You can also stage and undo individual hunks.    Make cscope support for go {% codeblock lang:bash %} find . -name \u0026ldquo;*.go\u0026rdquo; -print \u0026gt; cscope.files if cscope -b -k; then echo \u0026ldquo;Done\u0026rdquo; else echo \u0026ldquo;Failed\u0026rdquo; exit 1 fi {% endcodeblock %}\n然后下面粘贴一下我的.vimrc配置文件 {% codeblock .vimrc lang:vim %} set nocompatible filetype off set rtp+=~/.vim/bundle/Vundle.vim call vundle#begin() Plugin \u0026lsquo;VundleVim/Vundle.vim\u0026rsquo; Plugin \u0026lsquo;google/vim-maktaba\u0026rsquo; Plugin \u0026lsquo;google/vim-codefmt\u0026rsquo; Plugin \u0026lsquo;google/vim-glaive\u0026rsquo; Plugin \u0026lsquo;tpope/vim-fugitive\u0026rsquo; Plugin \u0026lsquo;vim-scripts/LargeFile\u0026rsquo; Plugin \u0026lsquo;scrooloose/nerdcommenter\u0026rsquo; \u0026ldquo;Plugin \u0026lsquo;altercation/vim-colors-solarized\u0026rsquo; Plugin \u0026lsquo;Lokaltog/vim-easymotion\u0026rsquo; Plugin \u0026lsquo;Raimondi/delimitMate\u0026rsquo; Plugin \u0026lsquo;mbbill/fencview\u0026rsquo; Plugin \u0026lsquo;vim-scripts/Visual-Mark\u0026rsquo; Plugin \u0026lsquo;Valloric/YouCompleteMe\u0026rsquo; Plugin \u0026lsquo;google/vim-searchindex\u0026rsquo; Plugin \u0026lsquo;fatih/vim-go\u0026rsquo; Plugin \u0026lsquo;scrooloose/nerdtree\u0026rsquo; Plugin \u0026lsquo;Xuyuanp/nerdtree-git-plugin\u0026rsquo; Plugin \u0026lsquo;google/vim-colorscheme-primary\u0026rsquo; Plugin \u0026lsquo;airblade/vim-gitgutter\u0026rsquo; Plugin \u0026lsquo;artur-shaik/vim-javacomplete2\u0026rsquo; Plugin \u0026lsquo;majutsushi/tagbar\u0026rsquo; call vundle#end() filetype plugin indent on call glaive#Install() call maktaba#plugin#Detect()\n\u0026quot; map leader key let mapleader = \u0026ldquo;,\u0026rdquo;\n\u0026quot; Large file let g:LargeFile=10\n\u0026quot; File encoding dectection set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1 set encoding=utf-8\n\u0026quot; Tab Settings set smarttab set tabstop=2 set softtabstop=2 set shiftwidth=2 set expandtab\n\u0026quot; Fix backspace indentation set backspace=indent,eol,start\n\u0026quot; Convince Vim it can use 256 colors set t_Co=256\nlet no_buffers_menu=1\n\u0026quot; Code Folding, everything foleded by default set foldmethod=indent set foldlevel=99 set foldenable\n\u0026quot; Turn off annoying swapfiles set noswapfile\n\u0026quot; Enable hidden buffers set hidden\n\u0026quot; Enable automatic title setting for terminals set title set titleold=\u0026quot;Terminal\u0026rdquo; set titlestring=%F\\ -\\ Vim\n\u0026quot; Activate a permanent ruler set ruler\n\u0026quot; Disable the stupid pydoc preview window for the omni completion set completeopt-=preview\n\u0026quot; Global by default set gdefault\n\u0026quot; Better Search set hlsearch\n\u0026quot; Hide matched on space nnoremap :nohlsearch\u0026quot; goto the middle of a line nnoremap m :call cursor(0, len(getline('.'))/2)\u0026quot; Quit windows on q nnoremap q :q\u0026quot; substitute nnoremap ss :%s/\n\u0026quot; next split and prev split nnoremap wl l nnoremap wh h nnoremap wj j nnoremap wk k\n\u0026quot; vsplit map nnoremap vp :vsplit\u0026quot; fencview \u0026ldquo;let g:fencview_autodetect=1\n\u0026quot; Make the commadn line two lines high and change the statusline display to \u0026quot; something that looks useful. set cmdheight=2 set laststatus=2 set showcmd set showmode set number\n\u0026quot; SuperTab let g:SuperTabDefaultCompletionType = \u0026ldquo;context\u0026rdquo;\n\u0026quot; Solarized Vim syntax enable set background=dark \u0026ldquo;let g:solarized_termtrans=1 \u0026ldquo;let g:solarized_termcolors=256 \u0026ldquo;let g:solarized_contrast=\u0026quot;high\u0026rdquo; \u0026ldquo;let g:solarized_visibility=\u0026quot;high\u0026rdquo; \u0026ldquo;colorscheme solarized colorscheme primary\n\u0026quot; set paste noremap sp :set pastenoremap cp :set nopaste\u0026quot; delimitMate let g:delimitMate_autoclose=1 let g:delimitMate_matchpairs=\u0026rdquo;(:),[:],{:}\u0026rdquo; let g:delimitMate_balance_matchpairs=1 let g:delimitMate_expand_cr=1\n\u0026quot; ycm let g:ycm_confirm_extra_conf=0 nnoremap :YcmDiag\u0026quot; not change clipboard xnoremap p pgvy\n\u0026quot; nerdTree for git let g:NERDTreeIndicatorMapCustom = { \\ \u0026ldquo;Modified\u0026rdquo; : \u0026ldquo;✹\u0026rdquo;, \\ \u0026ldquo;Staged\u0026rdquo; : \u0026ldquo;✚\u0026rdquo;, \\ \u0026ldquo;Untracked\u0026rdquo; : \u0026ldquo;✭\u0026rdquo;, \\ \u0026ldquo;Renamed\u0026rdquo; : \u0026ldquo;➜\u0026rdquo;, \\ \u0026ldquo;Unmerged\u0026rdquo; : \u0026ldquo;═\u0026rdquo;, \\ \u0026ldquo;Deleted\u0026rdquo; : \u0026ldquo;✖\u0026rdquo;, \\ \u0026ldquo;Dirty\u0026rdquo; : \u0026ldquo;✗\u0026rdquo;, \\ \u0026ldquo;Clean\u0026rdquo; : \u0026ldquo;✔︎\u0026rdquo;, \\ \u0026ldquo;Unknown\u0026rdquo; : \u0026ldquo;?\u0026rdquo; \\ }\n\u0026quot; open nerdTree map t :NERDTreeToggle\u0026quot; gitgutter nmap ]h GitGutterNextHunk nmap [h GitGutterPrevHunk\n\u0026quot; java complete2 autocmd FileType java setlocal omnifunc=javacomplete#Complete let g:JavaComplete_UseFQN=1 nmap (JavaComplete-Imports-Add) imap (JavaComplete-Imports-Add)\n\u0026quot; gotags let g:tagbar_type_go = { \\ \u0026lsquo;ctagstype\u0026rsquo; : \u0026lsquo;go\u0026rsquo;, \\ \u0026lsquo;kinds\u0026rsquo; : [ \\ \u0026lsquo;p:package\u0026rsquo;, \\ \u0026lsquo;i:imports:1\u0026rsquo;, \\ \u0026lsquo;c:constants\u0026rsquo;, \\ \u0026lsquo;v:variables\u0026rsquo;, \\ \u0026lsquo;t:types\u0026rsquo;, \\ \u0026lsquo;n:interfaces\u0026rsquo;, \\ \u0026lsquo;w:fields\u0026rsquo;, \\ \u0026lsquo;e:embedded\u0026rsquo;, \\ \u0026lsquo;m:methods\u0026rsquo;, \\ \u0026lsquo;r:constructor\u0026rsquo;, \\ \u0026lsquo;f:functions\u0026rsquo; \\ ], \\ \u0026lsquo;sro\u0026rsquo; : \u0026lsquo;.', \\ \u0026lsquo;kind2scope\u0026rsquo; : { \\ \u0026lsquo;t\u0026rsquo; : \u0026lsquo;ctype\u0026rsquo;, \\ \u0026lsquo;n\u0026rsquo; : \u0026lsquo;ntype\u0026rsquo; \\ }, \\ \u0026lsquo;scope2kind\u0026rsquo; : { \\ \u0026lsquo;ctype\u0026rsquo; : \u0026lsquo;t\u0026rsquo;, \\ \u0026lsquo;ntype\u0026rsquo; : \u0026lsquo;n\u0026rsquo; \\ }, \\ \u0026lsquo;ctagsbin\u0026rsquo; : \u0026lsquo;gotags\u0026rsquo;, \\ \u0026lsquo;ctagsargs\u0026rsquo; : \u0026lsquo;-sort -silent\u0026rsquo; \\ }\n\u0026quot; ctag nmap c :TagbarToggle{% endcodeblock %} 为了每次插件能与远端一直同步,可以用checkout我的vim配置项目\ngit clone https://github.com/mYmNeo/vim.git ~/.vim cd ~/.vim ./install.sh "
},
{
	"uri": "http://mymneo.github.io/_footer/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "People will never forget how you made them feel\n"
},
{
	"uri": "http://mymneo.github.io/posts/gdb-cheatsheet/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "GDB Cheatsheet  Copy Between Memory and a File  dump [format] memory filename start_addr end_addr dump [format] value filename expr Dump the contents of memory from start_addr to end_addr, or the value of expr, to filename in the given format. The format parameter may be any one of: binary Raw binary form. ihex Intel hex format. srec Motorola S-record format. tekhex Tektronix Hex format. verilog Verilog Hex format.  Show more line of source code  set listsize xxx "
},
{
	"uri": "http://mymneo.github.io/posts/kernel-development/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Kernel Development Cheatsheet  asmlinkage macro  The asmlinkage tag is one other thing that we should observe about this simple function. This is a #define for some gcc magic that tells the compiler that the function should not expect to find any of its arguments in registers (a common optimization), but only on the CPU\u0026rsquo;s stack. Recall our earlier assertion that system_call consumes its first argument, the system call number, and allows up to four more arguments that are passed along to the real system call. system_call achieves this feat simply by leaving its other arguments (which were passed to it in registers) on the stack. All system calls are marked with the asmlinkage tag, so they all look to the stack for arguments. Of course, in sys_ni_syscall\u0026rsquo;s case, this doesn\u0026rsquo;t make any difference, because sys_ni_syscall doesn\u0026rsquo;t take any arguments, but it\u0026rsquo;s an issue for most other system calls.\n __builtin_return_address(0)  get caller address\n __user, __kernel attribute   Some of the checks performed by Sparse require annotating the source code using the attribute GCC extension, or the Sparse-specific context specifier.[5] Sparse defines the following list of attributes:\naddress_space(num) bitwise force context(expression,in_context,out_context)\n so __user indicate the pointer is from user-space, kernel can\u0026rsquo;t dereference it. __kernel is objection.\n"
},
{
	"uri": "http://mymneo.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
}]